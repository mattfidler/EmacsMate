#+TITLE: My Org-mode setup
#+AUTHOR: Matthew L. Fidler
* Getting Started
This is my take based on reading http://doc.norang.ca/org-mode.html
Tasks are separated into logical groupings/projects.  For large task
groupings there are separate org-files.  Additionally, I have todos in
project readmes.  

Other than the project readmes, I have the followind org files to
collect non-work related tasks:

|-----------+---------------------------------------------|
| Filename  | Description                                 |
|-----------+---------------------------------------------|
| todo.org  | Main File of personal tasks                 |
|-----------+---------------------------------------------|

The following org-file collects org-capture notes and tasks.
|------------+-------------|
| Filename   | Description |
|------------+-------------|
| refile.org | GTD "Inbox" |
|------------+-------------|

The org-file has todo tasks on the local hard-drive or network drive.
** Agenda Setup.
=org-mode=

=org-mode= manages the =org-agenda-files= variable automatically using
=C-c [= and =C-c ]= to add and remove files respectively. I use this
to add README.org to my project list.
** Org Properties
** Key Bindings
:LOGBOOK:
CLOCK: [2011-12-15 Thu 08:51]--[2011-12-15 Thu 08:52] =>  0:01
:END:
Using ergo-emacs, I have the following custom key bindings setup for
emacs:
|-------+--------------------------------|
| Key   | For                            |
|-------+--------------------------------|
| C-M-m | Agenda                         |
| M-,   | Goto currently clocked in item |
| C-M-, | Org Clock in                   |
| M-m   | Org-Capture                    |
| M-<   | Clock in last task             |
|-------+--------------------------------|

#+BEGIN_SRC emacs-lisp
  (define-key ergoemacs-keymap (kbd "M-C-m") 'org-agenda)
  (define-key ergoemacs-keymap (kbd "M-m") 'org-capture)
  (define-key ergoemacs-keymap (kbd "M-,") 'org-clock-goto)
  (define-key ergoemacs-keymap (kbd "M-C-,") 'org-clock-in)
  (define-key ergoemacs-keymap (kbd "M-<") 'bh/clock-in-last-task)
  (define-key ergoemacs-keymap (kbd "M-b") 'mlf/punch-in-or-out) 
  (define-key global-keymap (kbd "C-ca") 'org-agenda)
  
  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key "\M-\C-n" 'outline-next-visible-heading)           
              (local-set-key "\M-\C-p" 'outline-previous-visible-heading)
              (local-set-key "\M-\C-u" 'outline-up-heading)
              ;; table
              (local-set-key "\M-\C-w" 'org-table-copy-region)
              (local-set-key "\M-\C-y" 'org-table-paste-rectangle)
              (local-set-key "\M-\C-l" 'org-table-sort-lines)
              ;; display images
              (local-set-key "\M-I" 'org-toggle-iimage-in-org)
              ;; yasnippet (using the new org-cycle hooks)
              (make-variable-buffer-local 'yas/trigger-key)
              (setq yas/trigger-key [tab])
              (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
              (define-key yas/keymap [tab] 'yas/next-field)
              ))
  
#+END_SRC
  
* Tasks and States
I would like to use one set of TODO keywords for all of my org files.
** Keywords
Here are my =TODO= keywords.  I got these from
http://doc.norang.ca/org-mode.html#sec-1-3
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "STARTED(s)" "|" "DONE(d!/!)")
                (sequence "WAITING(w@/@)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE"))))
  
  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "blue" :weight bold)
                ("STARTED" :foreground "blue" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)
                ("PHONE" :foreground "forest green" :weight bold))))
#+END_SRC

*** Normal Task States

Normal tasks go through the sequence =TODO= -> =DONE=.

The following diagram shows the possible state transitions for a task.

#+begin_src plantuml :file normal_task_states.png
  title Normal Task States
  [*] -> TODO
  TODO -> STARTED
  TODO -> DONE
  STARTED -> DONE
  DONE -> [*]
  TODO --> WAITING
  WAITING --> TODO
  STARTED --> WAITING
  WAITING --> STARTED
  HOLD --> CANCELLED
  WAITING --> CANCELLED
  CANCELLED --> [*]
  TODO --> HOLD
  HOLD --> TODO
  TODO --> CANCELLED
  TODO: t
  STARTED: s
  DONE: d
  WAITING:w
  note right of WAITING: Note records\nwhat it is waiting for
  HOLD:h
  note right of CANCELLED: Note records\nwhy it was cancelled
  CANCELLED:c
  WAITING --> DONE
#+end_src

#+results:
[[file:normal_task_states.png]]
*** Project Task States

I use a lazy project definition.  I don't like to bother with manually
stating 'this is a project' and 'that is not a project'.  For me a project
definition is really simple.  If a task has subtasks with a todo keyword
then it's a project.  That's it.

Projects can be defined at any level - just create a task with a todo
state keyword that has at least one subtask also with a todo state
keyword and you have a project.  Projects use the same todo keywords
as regular tasks with one exception - one subtask of a project needs
to be marked =NEXT= or =STARTED= so the project is not on the stuck
projects list.

#+begin_src plantuml :file task_states.png
  title Project Task States
  [*] -> TODO
  TODO -> NEXT
  NEXT -> STARTED
  NEXT -> DONE
  STARTED -> DONE
  DONE -> [*]
  TODO --> WAITING
  WAITING --> TODO
  HOLD --> CANCELLED
  NEXT --> WAITING
  WAITING --> NEXT
  STARTED --> WAITING
  WAITING --> STARTED
  WAITING --> CANCELLED
  TODO --> DONE
  CANCELLED --> [*]
  TODO --> HOLD
  HOLD --> TODO
  TODO --> CANCELLED
  TODO: t
  NEXT: n
  STARTED: s
  DONE: d
  WAITING:w
  note right of WAITING: Note records\nwhat it is waiting for
  HOLD:h
  note right of CANCELLED: Note records\nwhy it was cancelled
  CANCELLED:c
  WAITING --> DONE
#+end_src

#+results:
[[file:task_states.png]]
*** Phone Calls

Telephone calls are special.  They are created in a done state by a
capture task.  The time of the call is recorded for as long as the
capture task is active.  If I need to look up other details and want
to close the capture task early I can just =C-c C-c= to close the
capture task (stopping the clock) and then =f9 SPC= to resume the
clock in the phone call while I do other things.
#+begin_src plantuml :file phone_states.png
  title Phone Call Task State
  [*] -> PHONE
  PHONE -> [*]
#+end_src

#+results:
[[file:phone_states.png]]

* Adding New Tasks Quickly with Org Capture
:PROPERTIES:
:CUSTOM_ID: Capture
:END:


Org Capture mode replaces remember mode for capturing tasks and notes.

To add new tasks efficiently I use a minimal number of capture
templates.  I used to have lots of capture templates, one for each
org-file.  I'd start org-capture with M-m and then pick a template
that filed the task under =* Tasks= in the appropriate file.  

I want to use a minimal number of capture templates -- create the
new task quickly and refile it once.  This also saves me from
maintaining my org-capture templates when I add a new org file.

** Capture Templates
:PROPERTIES:
:CUSTOM_ID: CaptureTemplates
:END:

When a new task needs to be added I categorize it into one of a few
things:

- A phone call (p)
- A new task (t)
- A new note (n)
- An interruption (j)
- A new habit (h)

and pick the appropriate capture task.

Here is my setup for org-capture

#+begin_src emacs-lisp :tangle yes
  (setq org-default-notes-file "~/org/refile.org")
  
  ;; Capture templates for: TODO tasks, Notes, appointments, phone calls, and org-protocol
  (setq org-capture-templates
        (quote (("t" "todo" entry (file "~/org/refile.org")
                 "* TODO %?\n%U\n%a\n  %i" :clock-in t :clock-resume t)
                ("d" "Daily Review" plain (file+datetree "~/org/daily.org")
                 "%[~/org/five-minute.org]" :clock-in t :clock-resume t)
                ("k" "Weekly Review" plain (file+datetree "~/org/weekly.org")
                 "%[~/org/gtd-weekly.org]" :clock-in t :clock-resume t)
                ("n" "note" entry (file "~/org/refile.org")
                 "* %? :NOTE:\n%U\n%a\n  %i" :clock-in t :clock-resume t)
                ("j" "Journal" entry (file+datetree "~/org/diary.org")
                 "* %?\n%U\n  %i" :clock-in t :clock-resume t)
                ("w" "org-protocol" entry (file "~/org/refile.org")
                 "* TODO Review %c\n%U\n  %i" :immediate-finish t)
                ("o" "org-outlook" entry (file "~/org/refile.org") "* TODO Email %c %?\n  %i\n %U"
                 :clock-in t :clock-resume t)
                ("p" "Phone call" entry (file "~/org/refile.org")
                 "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)
                ("h" "Habit" entry (file "~/org/refile.org")
                 "* NEXT %?\n%U\n%a\nSCHEDULED: %t .+1d/3d\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n  %i"))))
  
#+end_src

The =%i= in the templates inserts any text in the kill ring as part of
the capture task.  This is intentionally indented from the rest of the
capture task details so that I can include text that starts with '* '
in column 1 without generating a new headline.

Capture mode now handles automatically clocking in and out of a
capture task.  This all works out of the box now without special hooks.
When I start a capture mode task the task is clocked in as specified
by =:clock-in t= and when the task is filed with =C-c C-c= the clock 
resumes on the original clocking task.

The quick clocking in and out of capture mode tasks (often it takes
less than a minute to capture some new task details) can leave
empty clock drawers in my tasks which aren't really useful.  Since I
remove clocking lines with 0:00 length I end up with a clock drawer
like this:

: * TODO New Capture Task
:   :LOGBOOK:
:   :END:
:   [2010-05-08 Sat 13:53]

I have the following setup to remove these empty =LOGBOOK= drawers if
they occur.

#+begin_src emacs-lisp :tangle yes
  ;; Remove empty LOGBOOK drawers on clock out
  (defun bh/remove-empty-drawer-on-clock-out ()
    (interactive)
    (save-excursion
      (beginning-of-line 0)
      (org-remove-empty-drawer-at "LOGBOOK" (point))))

  (add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)
#+end_src
** Separate file for Capture Tasks

I have a single org file which is the target for my capture templates.

I store notes, tasks, phone calls, and org-protocol tasks in
=refile.org=.  I used to use multiple files but found that didn't
really have any advantage over a single file.

Normally this file is empty except for a single line at the top which
creates a =REFILE= tag for anything in the file.

The file has a single permanent line at the top like this
: #+FILETAGS: REFILE
** Capture Tasks is all about being FAST

Okay I'm in the middle of something and oh yeah - I have to remember
to do that.  I don't stop what I'm doing.  I'm probably clocking a
project I'm working on and I don't want to lose my focus on that but I
can't afford to forget this little thing that just came up.

So what do I do?  Hit =M-m== to start capture mode and select =t=
since it's a new task and I get a buffer like this:

: ** TODO 
:    [2010-08-05 Thu 21:06]
:    [[file:~/org-mode-doc/org-mode.org::*Capture%20Tasks%20is%20all%20about%20being%20FAST][Capture Tasks is all about being FAST]]

Enter the details of the TODO item and =C-c C-c= to file it away in
refile.org and go right back to what I'm really working on secure in
the knowledge that that item isn't going to get lost and I don't have
to think about it anymore at all now.

The amount of time I spend entering the captured note is clocked.  The
capture templates are set to automatically clock in and out of the
capture task.  This is great for interruptions and telephone calls
too.

* Refiling Tasks
:PROPERTIES:
:CUSTOM_ID: Refiling
:END:

Refiling tasks is easy.  After collecting a bunch of new tasks in my
refile.org file using capture mode I need to move these to the
correct org file and topic.  All of my active org-files are in my
=org-agenda-files= variable and contribute to the agenda.

I collect capture tasks in refile.org for up to a week.  These now
stand out daily on my block agenda and I usually refile them during
the day.  I like to keep my refile task list empty.
** Refile Setup

To refile tasks in org you need to tell it where you want to refile things.

In my setup I let any file in =org-agenda-files= and the current file
contribute to the list of valid refile targets.  

I've recently moved to using IDO to complete targets directly.  I find
this to be faster than my previous complete in steps setup.  At first
I didn't like IDO but after reviewing the documentation again and
learning about =C-SPC= to limit target searches I find it is much
better than my previous complete-in-steps setup.  Now when I want to
refile something I do =C-c C-w= to start the refile process, then type
something to get some matching targets, then =C-SPC= to restrict the
matches to the current list, then continue searching with some other
text to find the target I need.  =C-j= also selects the current
completion as the final target.  I like this a lot.

I now exclude DONE state tasks as valid refile targets.  This helps to keep the
refile target list to a reasonable size.

Here is my refile configuration:
#+begin_src emacs-lisp :tangle yes
  ; Targets include this file and any file contributing to the agenda - up to 9 levels deep
  (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                   (org-agenda-files :maxlevel . 9))))
  
  ; Stop using paths for refile targets - we file directly with IDO
  (setq org-refile-use-outline-path nil)
  
  ; Targets complete directly with IDO
  (setq org-outline-path-complete-in-steps nil)
  
  ; Allow refile to create parent tasks with confirmation
  (setq org-refile-allow-creating-parent-nodes (quote confirm))
  
  ; Use IDO for both buffer and file completion and ido-everywhere to t
  (setq org-completion-use-ido t)
  (setq ido-everywhere t)
  (setq ido-max-directory-size 100000)
  (ido-mode (quote both))
  
  ;;;; Refile settings
  ; Exclude DONE state tasks from refile targets
  (defun bh/verify-refile-target ()
    "Exclude todo keywords with a done state from refile targets"
    (not (member (nth 2 (org-heading-components)) org-done-keywords)))
  
  (setq org-refile-target-verify-function 'bh/verify-refile-target)
  
#+end_src

To refile a task to my =norang.org= file under =System Maintenance= I
just put the cursor on the task and hit =C-c C-w= and enter =nor C-SPC
sys RET= and it's done.  IDO completion makes locating targets a snap.
** Refiling Tasks

Tasks to refile are in their own section of the block agenda.  To find
tasks to refile I run my agenda view with =C-M-m SPC= and scroll down to
second section of the block agenda: =Tasks to Refile=.  This view
shows all tasks (even ones marked in a =done= state).  Alternatively
I just use =C-M-m r= on my slower Eee PC.

Bulk refiling in the agenda works very well for multiple tasks going
to the same place.  Just mark the tasks with =m= and then =B r= to
refile all of them to a new location.  Occasionally I'll also refile
tasks as subtasks of the current clocking task using =C-2 C-c C-w=
from the =refile.org= file.

Refiling all of my tasks tends to take less than a minute so I
normally do this a couple of times a day.
** Refiling Notes

I keep a =* Notes= headline in most of my org-mode files.  Notes have
a =NOTE= tag which is created by the capture template for notes.  This
allows finding notes across multiple files easily using the agenda
search functions.

Notes created by capture tasks go first to =refile.org= and are later
refiled to the appropriate project file.  Some notes that are project
related get filed to the appropriate project instead of under the
catchall =* NOTES= task.  Generally these types of notes are specific
to the project and not generally useful -- so removing them from the
notes list when the project is archived makes sense.
** Refiling Phone Calls

Phone calls are handled using capture mode.  I time my calls using
the capture mode template settings to clock in and out the capture
task while the phone call is in progress.

Phone call tasks collect in =refile.org= and are later refiled to the
appropriate location.  Some phone calls are billable and we want these
tracked in the appropriate category.

* Custom agenda views

I now have one block agenda view that has everything on it.  I also
keep separate single view agenda commands for use on my slower Eee
PC - since it takes prohibitively long to generate my block agenda on
that slow machine.  I'm striving to simplify my layout with everything
at my fingertips in a single agenda on my workstation which is where I
spend the bulk of my time.

Most of my old custom agenda views were rendered obsolete when
filtering functionality was added to the agenda in newer versions of
=org-mode= and now with block agenda functionality I can combine
everything into a single view.

Custom agenda views are used for:
- Single block agenda shows the following
  - overview of today
  - Finding tasks to be refiled
  - Finding stuck projects
  - Finding NEXT tasks to work on
  - Reviewing projects
  - Show all TODO state tasks
  - Finding tasks waiting on something
  - Findings tasks to be archived
- Finding notes
- Viewing habits

If I want just today's calendar view then =C-M-m a= is still faster than
generating the block agenda - especially if I want to view a week or
month's worth of information.  In that case the extra detail on the
block agenda view is never really needed and I don't want to spend
time waiting for it to be generated.
** Setup

#+begin_src emacs-lisp :tangle yes
  (require 'org-habit)
  ;; Do not dim blocked tasks
  (setq org-agenda-dim-blocked-tasks nil)
  
  ;; Custom agenda command definitions
  (setq org-agenda-custom-commands
        (quote (("N" "Notes" tags "NOTE"
                 ((org-agenda-overriding-header "Notes")
                  (org-tags-match-list-sublevels t)))
                ("h" "Habits" tags-todo "STYLE=\"habit\""
                 ((org-agenda-overriding-header "Habits")
                  (org-agenda-sorting-strategy
                   '(todo-state-down effort-up category-keep))))
                (" " "Agenda"
                 ((agenda "" nil)
                  (tags "REFILE"
                        ((org-agenda-overriding-header "Notes and Tasks to Refile")
                         (org-agenda-overriding-header "Tasks to Refile")))
                  (tags-todo "-CANCELLED/!"
                             ((org-agenda-overriding-header "Stuck Projects")
                              (org-tags-match-list-sublevels 'indented)
                              (org-agenda-skip-function 'bh/skip-non-stuck-projects)))
                  (tags-todo "-WAITING-CANCELLED/!NEXT|STARTED"
                             ((org-agenda-overriding-header "Next Tasks")
                              (org-agenda-skip-function 'bh/skip-projects-and-habits)
                              (org-agenda-todo-ignore-scheduled t)
                              (org-agenda-todo-ignore-deadlines t)
                              (org-tags-match-list-sublevels t)
                              (org-agenda-sorting-strategy
                               '(todo-state-down effort-up category-keep))))
                  (tags-todo "-REFILE-CANCELLED/!-NEXT-STARTED-WAITING"
                             ((org-agenda-overriding-header "Tasks")
                              (org-agenda-skip-function 'bh/skip-projects-and-habits)
                              (org-agenda-todo-ignore-scheduled t)
                              (org-agenda-todo-ignore-deadlines t)
                              (org-agenda-sorting-strategy
                               '(category-keep))))
                  (tags-todo "-CANCELLED/!"
                             ((org-agenda-overriding-header "Projects")
                              (org-agenda-skip-function 'bh/skip-non-projects)
                              (org-tags-match-list-sublevels 'indented)
                              (org-agenda-sorting-strategy
                               '(category-keep))))
                  (todo "WAITING|HOLD"
                        ((org-agenda-overriding-header "Waiting and Postponed tasks")
                         (org-agenda-skip-function 'bh/skip-projects-and-habits)
                         (org-agenda-todo-ignore-scheduled t)
                         (org-agenda-todo-ignore-deadlines t)))
                  (tags "-REFILE/"
                        ((org-agenda-overriding-header "Tasks to Archive")
                         (org-agenda-skip-function 'bh/skip-non-archivable-tasks))))
                 nil)
                ("r" "Tasks to Refile" tags "REFILE"
                 ((org-agenda-overriding-header "Notes and Tasks to Refile")
                  (org-agenda-overriding-header "Tasks to Refile")))
                ("#" "Stuck Projects" tags-todo "-CANCELLED/!"
                 ((org-agenda-overriding-header "Stuck Projects")
                  (org-tags-match-list-sublevels 'indented)
                  (org-agenda-skip-function 'bh/skip-non-stuck-projects)))
                ("n" "Next Tasks" tags-todo "-WAITING-CANCELLED/!NEXT|STARTED"
                 ((org-agenda-overriding-header "Next Tasks")
                  (org-agenda-skip-function 'bh/skip-projects-and-habits)
                  (org-agenda-todo-ignore-scheduled t)
                  (org-agenda-todo-ignore-deadlines t)
                  (org-tags-match-list-sublevels t)
                  (org-agenda-sorting-strategy
                   '(todo-state-down effort-up category-keep))))
                ("R" "Tasks" tags-todo "-REFILE-CANCELLED/!-NEXT-STARTED-WAITING"
                 ((org-agenda-overriding-header "Tasks")
                  (org-agenda-skip-function 'bh/skip-projects-and-habits)
                  (org-agenda-sorting-strategy
                   '(category-keep))))
                ("p" "Projects" tags-todo "-CANCELLED/!"
                 ((org-agenda-overriding-header "Projects")
                  (org-agenda-skip-function 'bh/skip-non-projects)
                  (org-tags-match-list-sublevels 'indented)
                  (org-agenda-sorting-strategy
                   '(category-keep))))
                ("w" "Waiting Tasks" todo "WAITING|HOLD"
                 ((org-agenda-overriding-header "Waiting and Postponed tasks"))
                 (org-agenda-skip-function 'bh/skip-projects-and-habits)
                 (org-agenda-todo-ignore-scheduled 'future)
                 (org-agenda-todo-ignore-deadlines 'future))
                ("A" "Tasks to Archive" tags "-REFILE/"
                 ((org-agenda-overriding-header "Tasks to Archive")
                  (org-agenda-skip-function 'bh/skip-non-archivable-tasks))))))
#+end_src

My block agenda view looks like this:

I generally work top-down on the agenda.  Things with deadlines and
scheduled dates (planned to work on today or earlier) show up in the
agenda at the top.  When searching for tasks in the agenda I disable
display of child tasks with the following setting:

#+begin_src emacs-lisp :tangle yes
  (setq org-tags-match-list-sublevels nil)
#+end_src

This keeps the list of tasks I'm looking at to a reasonable size.  I
can always display child tasks for any specific task I want simply by
visiting it in the org buffer.

My day goes generally like this:

- Punch in (this starts the clock on the default task)
- Look at the agenda and make a mental note of anything important to deal with today
- Read email and news
  - create notes, and tasks for things that need responses with org-capture
- Check refile tasks and respond to emails
- Look at my agenda and work on important tasks for today
  - Clock it in
  - Work on it until it is =DONE= or it gets interrupted
- work on tasks
- Make journal entries (=M-m j=) for interruptions
- Punch out for lunch and punch back in after lunch
- work on more tasks
- Refile tasks to empty the list
  - Tag tasks to be refiled with =m= collecting all tasks for the same target
  - Bulk refile the tasks to the target location with =B r=
  - Repeat (or refile individually with =C-c C-w=) until all refile tasks are gone
- Mark habits done today as DONE
- Punch out at the end of the work day
** What do I work on next?
:PROPERTIES:
:CUSTOM_ID: WhatDoIWorkOnNext
:END:

Start with deadlines and tasks scheduled today or earlier from
the daily agenda view.  Then move on to tasks in the 
=Next Tasks= list in the block agenda view.

When I look for a new task to work on I generally hit =F12 SPC= to get
the block agenda and follow this order:

- Pick something off today's agenda
  - deadline for today (do this first - it's not late yet)
  - deadline in the past (it's already late)
  - a scheduled task for today (or in the past)
  - deadline that is coming up soon
- pick a NEXT task
- If you run out of items to work on look for a NEXT task in the current context
  pick a task from the Tasks list of the current project.
*** Why keep it all on the =NEXT= list?

I've moved to a more GTD way of doing things.  Now I just use a =NEXT=
list.  Only projects get tasks with =NEXT= keywords since stuck projects
initiate the need for marking or creating =NEXT= tasks.  A =NEXT= task
is something that is available to work on /now/, it is the next
logical step in some project.

I used to have a special keyword =ONGOING= for things that I do a lot
and want to clock but never really start/end.  I had a special agenda
view for =ONGOING= tasks that I would pull up to easily find the thing
I want to clock.

Since then I've moved away from using the =ONGOING= todo keyword.
Having an agenda view that shows =NEXT= tasks makes it easy to pick
the thing to clock - and I don't have to remember if I need to look in
the =ONGOING= list or the =NEXT= list when looking for the task to
clock-in.  The =NEXT= list is basically 'what is current' - any task
that moves a project forward.  I want to find the thing to work on as
fast as I can and actually do work on it - not spend time hunting
through my org files for the task that needs to be clocked-in.

To drop a task off the =NEXT= list simply move it back to the =TODO=
state.
** Reading email, newsgroups, and conversations on IRC

When reading email, newsgroups, and conversations on IRC I just let
the default task (normally =** Organization=) clock the time I spend
on these tasks.  I read everything in my inboxes.  If there are emails
that require a response I use org-capture to create a new task with a
heading of 'Respond to <user>' for each one.  This automatically links
to the email in the task and makes it easy to find later.  Some emails
are quick to respond to and some take research and a significant
amount of time to complete.  I clock each one in it's own task just in
case I need that clocked time later.

Next, I go to my newly created tasks to be refiled from the block
agenda with =M-C-m a= and clock in an email task and deal with it.
Repeat this until all of the 'Respond to <user>' tasks are marked
=DONE=.

I use =outlook-org= to capture information for ms outlook.

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'windows-nt)
    (require 'org-outlook nil t))
  (require 'org-protocol)
  
#+END_SRC


** Filtering

So many tasks, so little time.  I have hundreds of tasks at any given
time (373 right now).  There is so much stuff to look at it can be
daunting.  This is where agenda filtering saves the day.

It's 11:53AM and I'm in work mode just before lunch.  I don't want to
see tasks that are not work related right now.  I also don't want to
work on a big project just before lunch... so I need to find small
tasks that I can knock off the list.

How do we do this?  Get a list of NEXT tasks from the block agenda and
then narrow it down with filtering.  Tasks are ordered in the NEXT
agenda view by estimated effort so the short tasks are first -- just
start at the top and work your way down.  I can limit the displayed
agenda tasks to those estimates of 10 minutes or less with =/ + 1= and
I can pick something that fits the minutes I have left before I take
off for lunch.
*** Automatically removing context based tasks with / RET

=/ RET= in the agenda is really useful.  This awesome feature was
added to org-mode by John Wiegley.  It removes tasks automatically by
filtering based on a user-provided function.

At work I have projects I'm working on which are assigned by my
manager.  Sometimes priorities changes and projects are delayed to
sometime in the future.  This means I need to stop working on these
immediately.  I put the project task on =HOLD= and work on something
else.  The =/ RET= filter removes =HOLD= tasks and subtasks (because
of tag inheritance).

At home I have some tasks tagged with =@farm= since these need to be
performed when I am physically at our family farm.  Since I am there
infrequently I have added =@farm= to the list of auto-excluded tags on
my system.  I can always explicitly filter to just =@farm= tasks with
=/ TAB @farm RET= when I am physically there.

I have the following setup to allow =/ RET= to filter tasks based on
the description above.

#+begin_src emacs-lisp :tangle yes
  (defun bh/org-auto-exclude-function (tag)
    "Automatic task exclusion in the agenda with / RET"
    (and (cond
          ((string= tag "hold")
           t))
         (concat "-" tag)))
  
  (setq org-agenda-auto-exclude-function 'bh/org-auto-exclude-function)
  
#+end_src

This lets me filter tasks with just =/ RET= on the agenda which removes tasks I'm not
supposed to be working on now from the list of returned results.

This helps to keep my agenda clutter-free.

* Time Clocking
:PROPERTIES:
:CUSTOM_ID: Clocking
:END:

Okay, I admit it.  I'm a clocking fanatic.

I clock everything at work.  Org-mode makes this really easy.  I'd
rather clock too much stuff than not enough so I find it's easier to
get in the habit of clocking everything.

This makes it possible to look back at the day and see where I'm
spending too much time, or not enough time on specific projects.  This
also helps a lot when you need to estimate how long something is going
to take to do -- you can use your clocking data from similar tasks to
help tune your estimates so they are more accurate.

Without clocking data it's hard to tell how long something took to do
after the fact.

I now use the concept of =punching in= and =punching out= at the start
and end of my work day.  I punch in when I arrive at work, punch out
for lunch, punch in after lunch, and punch out at the end of the day.
Every minute is clocked between punch-in and punch-out times.

Punching in defines a default task to clock time on whenever the clock
would normally stop.  I found that with the default org-mode setup I
would lose clocked minutes during the day, a minute here, a minute
there, and that all adds up.  This is especially true if you write
notes when moving to a DONE state - in this case the clock normally
stops before you have composed the note -- and good notes take a few
minutes to write.

My clocking setup basically works like this:

- Punch in (start the clock)
  - This clocks in a predefined task by =org-id= that is the default
    task to clock in whenever the clock normally stops
- Clock in tasks normally, and let moving to a DONE state clock out
  - clocking out automatically clocks time on a parent task or moves
    back to the predefined default task if no parent exists.
- Continue clocking whatever tasks you work on
- Punch out (stop the clock)

I'm free to change the default task multiple times during the day but 
with the clock moving up the project tree on clock out I no longer 
need to do this.  I simply have a single task that gets clocked in
when I punch-in.

If I punch-in with a prefix on a task in =Project X= then that task
automatically becomes the default task and all clocked time goes on
that project until I either punch out or punch in some other task.

My org files look like this:

=todo.org=:
: #+FILETAGS: PERSONAL
: ...
: * Tasks
: ** Organization
: :PROPERTIES:
: :CLOCK_MODELINE_TOTAL: today
: :ID:       eb155a82-92b2-4f25-a3c6-0304591af2f9
: :END:
: ...

If I am working on some task, then I simply clock in on the task.
Clocking out moves the clock up to a parent task with a todo keyword
(if any) which keeps the clock time in the same subtree.  If there
is no parent task with a todo keyword then the clock moves back to
the default clocking task until I punch out or clock in some other
task.  When an interruption occurs I start a capture task which
keeps clocked time on the interruption task until I close it with
C-c C-c.

This works really well for me.

For example, consider the following org file:

: * TODO Project A
: ** NEXT TASK 1
: ** TODO TASK 2
: ** TODO TASK 3
: * Tasks
: ** TODO Some miscellaneous task

I'll work on this file in the following sequence:

1. I punch in with =F9-I= at the start of my day

   That clocks in the =Organization= task by id in my =todo.org= file.

2. =C-M-m-SPC= to review my block agenda

   Pick 'TODO Some miscellaneous task' to work on next and clock that in with =I=
   The clock is now on 'TODO Some miscellaneous task'

3. I complete that task and mark it done with =C-c C-t d=

   This stops the clock and moves it back to the =Organization= task.

4. Now I want to work on =Project A= so I clock in =Task 1=

   I work on Task 1 and mark it =DONE=.  This clocks out =Task 1= and moves
   the clock to =Project A=.  Now I work on =Task 2= and clock that in.

The entire time I'm working on and clocking some subtask of =Project A=
all of the clock time in the interval is applied somewhere to the =Project A=
tree.  When I eventually mark =Project A= done then the clock will move
back to the default organization task.
** Clock Setup
:PROPERTIES:
:CUSTOM_ID: ClockSetup
:END:

To get started we need to punch in which clocks in the default
task and keeps the clock running.  This is now simply a matter of
punching in the clock with =F9 I=.  You can do this anywhere.
Clocking out will now clock in the parent task (if there is one
with a todo keyword) or clock in the default task if not parent
exists.

Keeping the clock running when moving a subtask to a =DONE= state
means clocking continues to apply to the project task.  I can pick the
next task from the parent and clock that in without losing a minute or
two while I'm deciding what to work on next.

I keep clock times, state changes, and other notes in the =:LOGBOOK:=
drawer.

I have the following org-mode settings for clocking:

#+begin_src emacs-lisp :tangle yes
  ;;
  ;; Resume clocking tasks when emacs is restarted
  (org-clock-persistence-insinuate)
  ;;
  ;; Small windows on my Eee PC displays only the end of long lists which isn't very useful
  (setq org-clock-history-length 10)
  ;; Resume clocking task on clock-in if the clock is open
  (setq org-clock-in-resume t)
  ;; Change task to STARTED when clocking in
  (setq org-clock-in-switch-to-state 'bh/clock-in-to-started)
  ;; Separate drawers for clocking and logs
  (setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))
  ;; Save clock data and state changes and notes in the LOGBOOK drawer
  (setq org-clock-into-drawer t)
  ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
  (setq org-clock-out-remove-zero-time-clocks t)
  ;; Clock out when moving task to a done state
  (setq org-clock-out-when-done t)
  ;; Save the running clock and all clock history when exiting Emacs, load it on startup
  (setq org-clock-persist (quote history))
  ;; Enable auto clock resolution for finding open clocks
  (setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
  ;; Include current clocking task in clock reports
  (setq org-clock-report-include-clocking-task t)
  
  (setq bh/keep-clock-running nil)
  
  (defun bh/clock-in-to-started (kw)
    "Switch task from TODO or NEXT to STARTED when clocking in.
  Skips capture tasks."
    (if (and (member (org-get-todo-state) (list "TODO" "NEXT"))
             (not (and (boundp 'org-capture-mode) org-capture-mode)))
        "STARTED"))
  
  (defun bh/find-project-task ()
    "Move point to the parent (project) task if any"
    (let ((parent-task (save-excursion (org-back-to-heading) (point))))
      (while (org-up-heading-safe)
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task)
      parent-task))
  
  (defun mlf/punch-in-or-out (arg)
    (interactive "p")
    (if bh/keep-clock-running
        (bh/punch-out arg)
      (bh/punch-in arg)))
  
  (defun bh/punch-in (arg)
    "Start continuous clocking and set the default task to the
  selected task.  If no task is selected set the Organization task
  as the default task."
    (interactive "p")
    (setq bh/keep-clock-running t)
    (if (equal major-mode 'org-agenda-mode)
        ;;
        ;; We're in the agenda
        ;;
        (let* ((marker (org-get-at-bol 'org-hd-marker))
               (tags (org-with-point-at marker (org-get-tags-at))))
          (if (and (eq arg 4) tags)
              (org-agenda-clock-in '(16))
            (bh/clock-in-organization-task-as-default)))
      ;;
      ;; We are not in the agenda
      ;;
      (save-restriction
        (widen)
        ; Find the tags on the current task
        (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
            (org-clock-in '(16))
          (bh/clock-in-organization-task-as-default)))))
  
  (defun bh/punch-out ()
    (interactive)
    (setq bh/keep-clock-running nil)
    (when (org-clock-is-active)
      (org-clock-out))
    (org-agenda-remove-restriction-lock))
  
  (defun bh/clock-in-default-task ()
    (save-excursion
      (org-with-point-at org-clock-default-task
        (org-clock-in))))
  
  (defun bh/clock-in-parent-task ()
    "Move point to the parent (project) task if any and clock in"
    (let ((parent-task))
      (save-excursion
        (save-restriction
          (widen)
          (while (and (not parent-task) (org-up-heading-safe))
            (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
              (setq parent-task (point))))
          (if parent-task
              (org-with-point-at (or parent-task)
                (org-clock-in))
            (when bh/keep-clock-running
              (bh/clock-in-default-task)))))))
  
  (defvar bh/organization-task-id "default")
  
  (defun bh/clock-in-organization-task-as-default ()
    (interactive)
    (save-restriction
      (widen)
      (org-with-point-at (org-id-find bh/organization-task-id 'marker)
        (org-clock-in '(16)))))
  
  (defun bh/clock-out-maybe ()
    (when (and bh/keep-clock-running
               (not org-clock-clocking-in)
               (marker-buffer org-clock-default-task)
               (not org-clock-resolving-clocks-due-to-idleness))
      (bh/clock-in-parent-task)))
  
  (add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)
  
#+end_src

I used to clock in tasks by ID using the following function but with
the new punch-in and punch-out I don't need these as much anymore.
=f9-SPC= calls =bh/clock-in-last-task= which switches the clock back
to the previously clocked task.

#+begin_src emacs-lisp :tangle yes
  (require 'org-id)  
  (defun bh/clock-in-task-by-id (id)
    "Clock in a task by id"
    (save-restriction
      (widen)
      (org-with-point-at (org-id-find id 'marker)
        (org-clock-in nil))))

  (defun bh/clock-in-last-task (arg)
    "Clock in the interrupted task if there is one
  Skip the default task and get the next one.
  A prefix arg forces clock in of the default task."
    (interactive "p")
    (let ((clock-in-to-task
           (cond
            ((eq arg 4) org-clock-default-task)
            ((and (org-clock-is-active)
                  (equal org-clock-default-task (cadr org-clock-history)))
             (caddr org-clock-history))
            ((org-clock-is-active) (cadr org-clock-history))
            ((equal org-clock-default-task (car org-clock-history)) (cadr org-clock-history))
            (t (car org-clock-history)))))
      (org-with-point-at clock-in-to-task
        (org-clock-in nil))))
#+end_src
** Clocking in

When I start or continue working on a task I clock it in with any of the following:
k
  - =C-c C-x C-i= 
  - =I= in the agenda
  - =I= speed key on the first character of the heading line
  - =f9 I= while on the task in the agenda
  - =f9 I= while in the task in an org file
*** Setting a default clock task

I have a default =** Organization= task in my todo.org file that
I tend to put miscellaneous clock time on.  This is the task I
clock in on when I punch in at the start of my work day with
=F9-I=.  While reorganizing my org-files, reading email,
clearing my inbox, and doing other planning work that isn't for
a specific project I'll clock in this task.  Punching-in
anywhere clocks in this Organization task as the default task.

If I want to change the default clocking task I just visit the
new task in any org buffer and clock it in with =C-u C-u C-c C-x
C-i=.  Now this new task that collects miscellaneous clock
minutes when the clock would normally stop.

You can quickly clock in the default clocking task with =C-u C-c
C-x C-i d=.  Another option is to repeatedly clock out so the
clock moves up the project tree until you clock out the
top-level task and the clock moves to the default task.
*** Using the clock history to clock in old tasks

You can use the clock history to restart clocks on old tasks you've
clocked or to jump directly to a task you have clocked previously.  I
use this mainly to clock in whatever got interrupted by something.

Consider the following scenario:

- You are working on and clocking =Task A= (Organization)
- You get interrupted and switch to =Task B= (Document my use of org-mode)
- You complete =Task B= (Document my use of org-mode)
- Now you want to go back to =Task A= (Organization) again to continue

This is easy to deal with.  

1. Clock in =Task A=, work on it
2. Go to =Task B= (or create a new task) and clock it in
3. When you are finished with =Task B= hit =C-u C-c C-x C-i i=

This displays a clock history selection window like the following and
selects the interrupted =[i]= entry.

*Clock history selection buffer for C-u C-c C-x C-i*
#+begin_example
  Default Task
  [d] norang          Organization                          <-- Task B
  The task interrupted by starting the last one
  [i] norang          Organization                          <-- Task B
  Current Clocking Task
  [c] org             NEXT Document my use of org-mode      <-- Task A
  Recent Tasks
  [1] org             NEXT Document my use of org-mode      <-- Task A
  [2] norang          Organization                          <-- Task B
  ...
  [Z] org             DONE Fix default section links        <-- 35 clock task entries ago
#+end_example
** Clock Everything - Create New Tasks

In order to clock everything you need a task for everything.  That's
fine for planned projects but interruptions inevitably occur and you
need some place to record whatever time you spend on that
interruption.

To deal with this we create a new capture task to record the thing we
are about to do.  The workflow goes something like this:

- You are clocking some task and an interruption occurs
- Create a quick capture task journal entry =C-M-r j=
- Type the heading
- go do that thing (eat lunch, whatever)
- file it =C-c C-c=, this restores the clock back to the previous clocking task
- clock something else in or continue with the current clocking task

This means you can ignore the details like where this task really
belongs in your org file layout and just get on with completing the
thing.  Refiling a bunch of tasks later in a group when it is
convenient to refile the tasks saves time in the long run.

If it's a one-shot uninteresting task (like a coffee break) I create
a capture journal entry for it that goes to the diary.org date tree.
If it's a task that actually needs to be tracked and marked done, and 
applied to some project then I create a capture task instead which files it in 
refile.org.
** Finding tasks to clock in

To find a task to work on I use one of the following options
(generally listed most frequently used first)

- Use the clock history C-u C-c C-x C-i
  Go back to something I was clocking that is not finished
- Pick something off today's block agenda
  =SCHEDULED= or =DEADLINE= items that need to be done soon
- Pick something off the =NEXT= tasks agenda view
  Work on some unfinished task to move to completion
- Pick something off the other task list 
- Use an agenda view with filtering to pick something to work on

Punching in on the task you select will restrict the agenda view to that project
so you can focus on just that thing for some period of time.
** Editing clock entries

Sometimes it is necessary to edit clock entries so they reflect
reality.  I find I do this for maybe 2-3 entries in a week.

Occassionally I cannot clock in a task on time because I'm away from
my computer.  In this case the previous clocked task is still running
and counts time for both tasks which is wrong.

I make a note of the time and then when I get back to my computer I
clock in the right task and edit the start and end times to correct
the clock history.

To visit the clock line for an entry quickly use the agenda log mode.
=C-M-m a l= shows all clock lines for today.  I use this to navigate to
the appropriate clock lines quickly.  F11 goes to the current clocked
task but the agenda log mode is better for finding and visiting older
clock entries.

Use =C-M-m a l= to open the agenda in log mode and show only logged
clock times.  Move the cursor down to the clock line you need to edit
and hit =TAB= and you're there.

To edit a clock entry just put the cursor on the part of the date you
want to edit (use the keyboard not the mouse - since the clicking on
the timestamp with the mouse goes back to the agenda for that day) and
hit the =S-<up arrow>= or =S-<down arrow>= keys to change the time.

The following setting makes time editing use discrete minute intervals (no rounding)
increments:
#+begin_src emacs-lisp :tangle yes
  (setq org-time-stamp-rounding-minutes (quote (1 1)))
#+end_src

Editing the time with the shift arrow combination also updates the
total for the clock line which is a nice convenience.

I always check that I haven't created task overlaps when fixing time
clock entries by viewing them with log mode on in the agenda.  There
is a new view in the agenda for this -- just hit =v c= in the daily 
agenda and clock gaps and overlaps are identified.

I want my clock entries to be as accurate as possible.

The following setting shows 1 minute clocking gaps.
#+begin_src emacs-lisp :tangle yes
  (setq org-agenda-clock-consistency-checks
        (quote (:max-duration "4:00"
                :min-duration 0
                :max-gap 0
                :gap-ok-around ("4:00"))))
#+end_src
* Time reporting and tracking
** Billing clients based on clocked time

At the beginning of the month I invoice my clients for work done last
month.  This is where I review my clocking data for correctness before
billing for the clocked time.

Billing for clocked time basically boils down to the following steps:

1. Verify that the clock data is complete and correct
2. Use clock reports to summarize time spent
3. Create an invoice based on the clock data

   I currently create invoices in an external software package
   based on the org-mode clock data.

4. Archive complete tasks so they are out of the way.

   See [[#Archiving][Archiving]] for more details.
*** Verify that the clock data is complete and correct

Since I change tasks often (sometimes more than once in a minute) I
use the following setting to remove clock entries with a zero
duration.
#+begin_src emacs-lisp :tangle yes
  ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
  (setq org-clock-out-remove-zero-time-clocks t)
#+end_src

This setting just keeps my clocked log entries clean - only keeping
clock entries that contribute to the clock report.

Before invoicing for clocked time it is important to make sure your
clocked time data is correct.  If you have a clocked time with an
entry that is not closed (ie. it has no end time) then that is a hole
in your clocked day and it gets counted as zero (0) for time spent on
the task when generating clock reports.  Counting it as zero is almost
certainly wrong.

To check for unclosed clock times I use the agenda-view clock check
(=v c= in the agenda).  This view shows clocking gaps and overlaps in
the agenda.

To check the last month's clock data I use =C-M-m a v m b v c=
which shows a full month in the agenda, moves to the previous
month, and shows the clocked times only.  It's important to
remove any agenda restriction locks and filters when checking
the logs for gaps and overlaps.

The clocked-time only display in the agenda makes it easy to quickly
scan down the list to see if an entry is missing an end time.  If an
entry is not closed you can manually fix the clock entry based on
other clock info around that time.

Use the following setup to get log mode in the agenda to only show
clocked times:
#+begin_src emacs-lisp :tangle yes
  ;; Agenda log mode items to display (clock time only by default)
  (setq org-agenda-log-mode-items (quote (clock)))
#+end_src
*** Using clock reports to summarize time spent

Billable time for clients are kept in separate org files.

To get a report of time spent on tasks for =XYZ.org= you simply visit
the =XYZ.org= file and run an agenda clock report for the last month
with =C-M-m < a v m b R=.  This limits the agenda to this one file,
shows the agenda for a full month, moves to last month, and generates
a clock report.

My agenda org clock report settings show 5 levels of detail with links
to the tasks.
#+begin_src emacs-lisp :tangle yes
  ;; Agenda clock report parameters
  (setq org-agenda-clockreport-parameter-plist
        (quote (:link t :maxlevel 5 :fileskip0 t :compact t)))
#+end_src

I used to have a monthly clock report dynamic block in each project
org file and manually updated them at the end of my billing cycle.  I
used this as the basis for billing my clients for time spent on their
projects.  I found updating the dynamic blocks fairly tedious when you
have more than a couple of files for the month.

I have since moved to using agenda clock reports shortly after that
feature was added.  I find this much more convenient.  The data isn't
normally for consumption by anyone else so the format of the agenda
clock report format is great for my use-case.
** Task Estimates and column view
:PROPERTIES:
:CUSTOM_ID: TaskEstimates
:END:

Estimating how long tasks take to complete is a difficult skill to
master.  Org-mode makes it easy to practice creating estimates for
tasks and then clock the actual time it takes to complete.

By repeatedly estimating tasks and reviewing how your estimate relates
to the actual time clocked you can tune your estimating skills.
*** Creating a task estimate with column mode

I use =properties= and =column view= to do project estimates.

I set up column view globally with the following headlines
#+begin_src emacs-lisp :tangle yes
  ; Set default column view headings: Task Effort Clock_Summary
  (setq org-columns-default-format "%70ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM")
#+end_src

This makes column view show estimated task effort and clocked times
side-by-side which is great for reviewing your project estimates.

A property called =Effort= records the estimated amount of time a
given task will take to complete.  The estimate times I use are one
of:

- 10 minutes
- 30 minutes
- 1 hour
- 2 hours
- 3 hours
- 4 hours
- 5 hours
- 6 hours
- 7 hours
- 8 hours

These are stored for easy use in =column mode= in the global property
=Effort_ALL=.
#+begin_src emacs-lisp :tangle yes
  ; global Effort estimate values
  ; global STYLE property values for completion
  (setq org-global-properties (quote (("Effort_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                      ("STYLE_ALL" . "habit"))))
#+end_src

To create an estimate for a task or subtree start column mode with
=C-c C-x C-c= and collapse the tree with =c=.  This shows a table
overlayed on top of the headlines with the task name, effort estimate,
and clocked time in columns.

With the cursor in the =Effort= column for a task you can easily set
the estimated effort value with the quick keys =1= through =9=.

After setting the effort values exit =column mode= with =q=.
*** Saving your estimate
:PROPERTIES:
:CUSTOM_ID: SavingEstimate
:END:

For fixed price jobs where you provide your estimate to a client, then
work to complete the project it is useful to save the original
estimate that is provided to the client.

Save your original estimate by creating a dynamic clock report table
at the top of your estimated project subtree.  Entering =C-c C-x i
RET= inserts a clock table report with your estimated values and any
clocked time to date.

: Original Estimate
: #+BEGIN: columnview :hlines 1 :id local
: | Task                        | Estimated Effort | CLOCKSUM |
: |-----------------------------+------------------+----------|
: | ** TODO Project to estimate |             5:40 |          |
: | *** TODO Step 1             |             0:10 |          |
: | *** TODO Step 2             |             0:10 |          |
: | *** TODO Step 3             |             5:10 |          |
: | **** TODO Step 3.1          |             2:00 |          |
: | **** TODO Step 3.2          |             3:00 |          |
: | **** TODO Step 3.3          |             0:10 |          |
: | *** TODO Step 4             |             0:10 |          |
: #+END:

I normally delete the =#+BEGIN:= and =#+END:= lines from the original
table after providing the estimate to the client to ensure I don't
accidentally update the table by hitting =C-c C-c= on the =#+BEGIN:=
line.

Saving the original estimate data makes it possible to refine the
project tasks into subtasks as you work on the project without losing
the original estimate data.
*** Reviewing your estimate

=Column view= is great for reviewing your estimate.  This shows your
estimated time value and the total clock time for the project
side-by-side.

Creating a dynamic clock table with =C-c C-x i RET= is a great way to
save this project review if you need to make it available to other
applications.

=C-c C-x C-d= also provides a quick summary of clocked time for the
current org file.
** Don't spend too much time!
Try not to spend too much time on any one task. Therefore when you are
over your estimated time sound an alert.
#+BEGIN_SRC emacs-lisp
  (setq org-clock-sound (expand-file-name "~init/shared/bang_6.wav"))
#+END_SRC

* Org-mode options
** Code Blocks
Org-babel currently supported languages
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (sh . t)
     (R . t)
     (plantuml . t)
     (perl . t)
     (ruby . t)
     (python . t)
     (js . t)
     (haskell . t)
     (clojure . t)
     (ditaa . t)))
  
  (setq org-confirm-babel-evaluate nil)
  
#+END_SRC

Reading/Editing code inside org-mode code-blocks is much more like
reading and editing of code using its major mode

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
#+END_SRC


** Handling blank lines

Blank lines are evil :).  They keep getting inserted in between
headlines and I don't want to see them in collapsed (contents) views.
When I use =TAB= to fold (cycle) tasks I don't want to see any blank
lines but the default =org-cycle-separate-lines= setting hides single
blank lines and reveals where extra empty lines are created in the
document.  I'd rather not see blank lines at all in collapsed views.

The following setting hides all blank lines inside folded contents of
headings:

#+begin_src emacs-lisp :tangle yes
  (setq org-cycle-separator-lines 0)
#+end_src

I find extra blank lines in lists and headings a bit of a nuisance.
To get a body after a list you need to include a blank line between
the list entry and the body -- and indent the body appropriately.
Most of my lists have no body detail so I like the look of collapsed
lists with no blank lines better.

The following setting prevents creating blank lines before list items
and headings:

#+begin_src emacs-lisp :tangle yes
  (setq org-blank-before-new-entry (quote ((heading)
                                           (plain-list-item))))
#+end_src
** Org mode display image files
CLOSED: [2011-12-16 Fri 16:59]
- State "DONE"       from "STARTED"    [2011-12-16 Fri 16:59]
:LOGBOOK:
CLOCK: [2011-12-16 Fri 16:58]--[2011-12-16 Fri 16:59] =>  0:01
CLOCK: [2011-12-16 Fri 16:45]--[2011-12-16 Fri 16:58] =>  0:13
:END:
Using iimage mode, See [[http://orgmode.org/worg/org-configs/org-config-examples.html#sec-2-2][iimage in org]].
- iimage 
#+BEGIN_SRC emacs-lisp
  (require 'iimage)
  (add-to-list 'iimage-mode-image-regex-alist
               (cons (concat "\\[\\[file:\\(~?" iimage-mode-image-filename-regex
                             "\\)\\]")  1))
  
  (defun org-toggle-iimage-in-org ()
    "display images in your org file"
    (interactive)
    (if (face-underline-p 'org-link)
        (set-face-underline-p 'org-link nil)
      (set-face-underline-p 'org-link t))
    (iimage-mode))
  (add-hook 'org-mode-hook 'org-toggle-iimage-in-org)
  
#+END_SRC


** Edit code in a single window
I use =C-s= to save all the time.  The default org-mode editing
mechanism changes my window position :(.  Therefore, I prefer to edit
the org-mode files in the current window.
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
  
#+END_SRC

** Let =C-w= exit the source code view
#+BEGIN_SRC emacs-lisp
(define-key org-src-mode-map "\C-w" 'org-edit-src-exit)
#+END_SRC

** Over the top Saving of Org-buffers.
   I would like refile to save the buffer
#+BEGIN_SRC emacs-lisp
(add-hook 'org-after-refile-insert-hook 'save-buffer)
(add-hook 'org-capture-after-finalize-hook 'save-buffer)
(defadvice org-refile (around save-after-refile)
  ad-do-it
  (save-buffer))
(ad-activate 'org-refile)
#+END_SRC

** Handling Bibtex References
François Lagarde describes what do do in org when [[http://article.gmane.org/gmane.emacs.orgmode/2406/match%3Dbibliography][dealing with a
bibliography]].  Later, I found a more comprehensive solution at
[[http://tincman.wordpress.com/2011/01/04/research-paper-management-with-emacs-org-mode-and-reftex/][Research Paper Management with Emacs, org-mode and RefTeX « Mathletic]].
Combining this with http://orgmode.org/worg/org-faq.html, gives:

Adapting this to my taste, gives:

#+BEGIN_SRC emacs-lisp
  (defun org-mode-reftex-setup ()
    (interactive)
    (load-library "reftex")
    (and (buffer-file-name) (file-exists-p (buffer-file-name))
         (progn
           ;;enable auto-revert-mode to update reftex when bibtex file
           ;;changes on disk
           (global-auto-revert-mode t)
           (reftex-parse-all)
           ;;add a custom reftex cite format to insert links
           (reftex-set-cite-format
            '((?b . "[[bib:%l][%l-bib]]")
              (?n . "[[notes:%l][%l-notes]]")
              (?p . "[[pdf:%l][%l-paper]]")
              (?t . "%t")
              (?h . "** %t\n:PROPERTIES:\n:Custom_ID: %l\n:END:\n[[papers:%l][%l-paper]]")))))
    (define-key org-mode-map (kbd "C-c )") 'reftex-citation)
    (define-key org-mode-map (kbd "C-c (") 'org-mode-reftex-search))
  
  (add-hook 'org-mode-hook 'org-mode-reftex-setup)
  
  
  (defun org-mode-reftex-search ()
    ;;jump to the notes for the paper pointed to at from reftex search
    (interactive)
    (org-open-link-from-string (format "[[notes:%s]]" (reftex-citation t))))
  
  (setq org-link-abbrev-alist
        '(("bib" . "~/Articles/generalOcular.bib::%s")
          ("notes" . "~/Articles/generalOcular.org::#%s")
          ("pdf" . "~/Articles/PDF/%s.pdf")))
  
#+END_SRC

* Org Export
I would like to produce =doc= files, this is done by changing the
=org-export-odt-preferred-output-format= in conjunction with
LibreOffice.

#+BEGIN_SRC emacs-lisp
  (setq org-export-odt-preferred-output-format "doc")
#+END_SRC



* Org-mode Wish List/Todo List
** TODO Make org-clocking save buffer after clocking in.
[2011-12-15 Thu 15:19]
[[file:~/org/todo.org::*Gym][Gym]]
** TODO Make archive save the file
[2011-12-15 Thu 16:47]
[[file:~/org/todo.org_archive]]
** STARTED Make org-mode do checklists like on the screen shots
:LOGBOOK:
CLOCK: [2011-12-16 Fri 16:37]--[2011-12-16 Fri 16:45] =>  0:08
:END:
