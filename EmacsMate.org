#+TITLE: EmacsMate
#+AUTHOR: Matthew L. Fidler
* Introduction
[[http://manual.macromates.com/en/][TextMate]] is a popular editor for Mac OS X.  I don't believe it can be
configured as much as emacs, but some of the features are fairly
intuitive.  Emacs can replicate much of the textmate functionality.
This is a literate startup file based on Emacs Capabilities that do
the same thing as textmate.
* Project Management
Project management is not built into emacs.  There are a few different
project management tools for emacs:
- [[https://github.com/bbatsov/projectile][Projectile]]
- [[http://stackoverflow.com/questions/978984/is-there-a-good-emacs-project-management-somewhere][Is there a good Emacs project management somewhere? ]]
- [[http://misspent.wordpress.com/2011/05/31/eproject-anything-simple-emacs-project-management/][eproject + anything: simple emacs project management]].

I have implemented projectile support because it has some support for
version control-based projects.

** Creating Projects
Projects with projectile are created from github, bzr, etc
repositories are automatically considered projects.
** Filtering Unwanted files
Unwanted files are filtered with a =.projectile= file.
** Navigating files in a project
When files are opened, the tabbar groups them by Projectile Project.
** Find and Replace in Projects
This can be accessed in the Projectile menu or keybindings.
** Moving between project files

** Using Helm

* Key Bindings
Typically TextMate uses [[http://www.emacswiki.org/CuaMode][Cua Mode]].  This does not provide all the
traditional key bindings, so I also use [[http://ergoemacs.org/emacs/ergonomic_emacs_keybinding.html][ErgoEmacs Keybindings]]. This
doesn't quite work with org-mode, so as a hack, I have devised
[[https://github.com/mlf176f2/org-cua-dwim.el][org-cua-dwim.el]].                
* Templates
Textmate implements templates on creating a new file, see
[[http://manual.macromates.com/en/templates][TextMate Manual » Templates]].  Currently, the new file templates are
unimplemented. 
* Printing
:PROPERTIES:
:ID: 67b9db54-665d-408b-b156-0377eaf884c2
:END:
Printing in Emacs are discussed in the following places:
- [[http://www.emacswiki.org/emacs/PrintingFromEmacs][EmacsWiki: Printing From Emacs]]

Under windows:

- [[http://www.leedberg.com/2005/11/how-to-printing-in-emacs-under-windows.html][Leedberg.com: How-To: Printing in Emacs Under Windows]]
- [[http://stackoverflow.com/questions/569758/how-do-i-print-from-emacs-on-win32][winapi - How do I print from Emacs on Win32? - Stack Overflow]]
- [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Windows-Printing.html#Windows-Printing][Windows Printing - GNU Emacs Manual]]
- [[http://gregorygrubbs.com/emacs/10-tips-emacs-windows/][10 Tips for Powerful Emacs on Windows]]

This is implemented in the [[id:3484edff-15e3-47d5-85e5-76251d4b8776][Printing]] section.

* Bookmarks
:PROPERTIES:
:ID: 99a99dfe-41b6-40ec-ae8e-44d2a3d8ae81
:END:
Bookmarks are implemented in Emacs, see [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Bookmarks.html][GNU Emacs Manual]].  
Other discussions for bookmarks are located at:
- [[http://emacswiki.org/emacs/BookMarks][EmacsWiki: Book-marks]]
- [[http://ergoemacs.org/emacs/bookmark.html][Using Emacs's Bookmark Feature]]
- [[http://emacs-fu.blogspot.com/2009/11/bookmarks.html][emacs-fu: bookmarks]]
- [[http://emacsblog.org/2007/03/22/bookmark-mania/][Bookmark Mania | M-x all-things-emacs]]

Like anything in emacs, you can extend bookmarks, see:
- [[http://cedet.sourceforge.net/visbookmark.shtml][EIEIO Visual Studio style bookmarks]]
- [[http://www.emacswiki.org/emacs/BookmarkPlus#Bookmark%252b][Bookmark Plus]]
- [[http://www.emacswiki.org/emacs/BreadcrumbForEmacs][Breadcrumb For Emacs]]
- [[http://www.emacswiki.org/emacs/EshellBmk][Eshell Bmk]]
- [[http://www.emacswiki.org/emacs/GraphicalBookmarkJump][Graphical Bookmark Jump]]
- [[http://www.emacswiki.org/emacs/VisibleBookmarks][Visible Bookmarks]]
- [[http://www.emacswiki.org/emacs/wuxch-bookmark.el][wuxch-bookmark.el]]
- [[https://github.com/joodland/bm][Visible bookmarks in buffer (joodland/bm)]]

TextMate uses a visual-studio style bookmarks (See [[http://manual.macromates.com/en/navigation_overview][TextMate Manual »
Navigation / Overview]]).  Therefore to duplicate both textmate's
behavior and visual studio's behavior there are two options:
- [[https://github.com/joodland/bm][Visible bookmarks in buffer (joodland/bm)]]
- [[http://cedet.sourceforge.net/visbookmark.shtml][EIEIO Visual Studio style bookmarks]]

I choose the Visible bookmarks in buffers because it not only adds
visual studio style bookmarks, but also shows a visual cue of where
these bookmarks are.

The Keyboard bindings for the bookmarks are:

|------------+-------------------|
| Key        | Action            |
|------------+-------------------|
| Control-F2 | Toggle Bookmarks  |
| F2         | Next Bookmark     |
| Shift-F2   | Previous Bookmark |
|------------+-------------------|

This is setup in [[id:2c39ce29-8541-4cd3-9715-ec0f0d368eb1][Bookmarks]], below

* Collapsing Text Blocks 
Hide-Show collapses text blocks.  I implement hideshowvis to implement
collapsing of blocks
* Code Navigation
** Customizing
* Working with Text
** Auto-paired characters
TextMate Handles autopaired characters as follows:
[[http://manual.macromates.com/en/working_with_text#auto-paired_characters_quotes_etc][TextMate Manual - Working With Text - Auto-Paired Characters]]
This is implemented by autopair-mode
** Code Completion

** Copy and Paste

** Moving Text
*** Increase/Decrease Indent Level

*** Move Text Up/Down/Left/Right

*** Re-indent-text

** Selecting Text
*** Editing Multiple Lines
** Smart Tab

** Spell Checking

* Modes
* Snippets
** Importing Textmate bundles
* Shell Commands
* Drag Commands
* Themes
* Working with Version Control
* Macros
* Regular Expressions
* Calling Emacs from other applications
See [[http://manual.macromates.com/en/using_textmate_from_terminal.html][Calling TextMate from Other Applications]]
** Browsers
*** Chromium/Chrome
Type Control-Shift-B.  Add a bookmark.  The name should be Org Capture

The web address should be:
#+BEGIN_SRC js
  javascript:location.href='org-protocol://capture://'+encodeURIComponent(location.href)+'/'+encodeURIComponent(document.title)+'/'+encodeURIComponent(window.getSelection()).replace(/'/g,"%27").replace(/\(/g,"%28").replace(/\)/g,"%29")javascript:location.href='org-protocol://capture://'+encodeURIComponent(location.href)+'/'+encodeURIComponent(document.title)+'/'+encodeURIComponent(window.getSelection()).replace(/'/g,"%27").replace(/\(/g,"%28").replace(/\)/g,"%29")
#+END_SRC

You could also set the sub-protocol in the capture dialog.  To use the
org-protocol template included in EmacsMate, use:

#+BEGIN_SRC js
  javascript:location.href='org-protocol://capture://w/'+encodeURIComponent(location.href)+'/'+encodeURIComponent(document.title)+'/'+encodeURIComponent(window.getSelection()).replace(/'/g,"%27").replace(/\(/g,"%28").replace(/\)/g,"%29")javascript:location.href='org-protocol://capture://'+encodeURIComponent(location.href)+'/'+encodeURIComponent(document.title)+'/'+encodeURIComponent(window.getSelection()).replace(/'/g,"%27").replace(/\(/g,"%28").replace(/\)/g,"%29")
#+END_SRC


Add another bookmark the name should be Org Store Link

The web address should be:
#+BEGIN_SRC js
  javascript:location.href='org-protocol://store-link://'+encodeURIComponent(location.href)+'/'+encodeURIComponent(document.title)
#+END_SRC

You could also make this bound to key by using Google Chrome's
Shortcut Manager.


** Shell

** Editor

** TeX Editor
** From Less
* Customizing Emacs More
* Getting Help
* Implementation
This is based on my changing [[http://eschulte.me/emacs24-starter-kit/][Emacs Starter Kit]] and [[http://batsov.com/prelude/][Prelude]]
** Declaring functions that are unknown to compilers
#+BEGIN_SRC emacs-lisp
  (declare-function ergoemacs-kbd "ergoemacs-mode")
  (declare-function ergoemacs-setup-keys "ergoemacs-mode")
  (declare-function ergoemacs-mode "ergoemacs-mode")
  (declare-function org-cua-dwim-activate "org-cua-dwim")
  
  (declare-function ac-config-default "auto-complete-config")
  
  (declare-function pos-tip-w32-max-width-height "pos-tip")
  
  (declare-function ido-ubiquitous "ido-ubiquitous")
  
  (declare-function yas-global-mode "yasnippet")
  (declare-function yas-load-directory "yasnippet")
  (declare-function yas-expand "yasnippet")
  
  (declare-function ssh "ssh")
  
  (declare-function global-undo-tree-mode "undo-tree")
  
  (declare-function projectile-global-mode "projectile")
  (declare-function projectile-project-root "projectile")
  (declare-function projectile-project-name "projectile")
  
  (declare-function package-installed-p "package")
  (declare-function package-version-join "package")
  (declare-function package-desc-vers "package")
  (declare-function package--dir "package")
#+END_SRC

** Functions and Customization Groups
*** Customizable group
#+BEGIN_SRC emacs-lisp
  (defgroup emacsmate nil
    "EmacsMate Customization Options"
    :group 'emacs)
#+END_SRC
*** Required ELPA packages
#+BEGIN_SRC emacs-lisp
  (defvar emacsmate-packages
    '(org-outlook
      ace-jump-mode
      smartparens
      auto-complete
      auto-indent-mode
      keyfreq
      golden-ratio
      ergoemacs-mode
      helm
      helm-projectile
      undo-tree
      ido-ubiquitous
      melpa
      org-cua-dwim
      org-table-comment
      pos-tip
      ;;smex
      yasnippet
      ssh
      htmlize
      ;;zenburn-theme
      extend-dnd
      ;;solarized-theme
      monokai-theme
      textmate-to-yas
      multiple-cursors
      expand-region
      dired+
      info+
      linum-off
      projectile
      powerline
      diminish
      header2
      lib-requires
      tabbar-ruler)
    "Libraries that should be installed by default.")
  
#+END_SRC

*** ELPA functions
#+BEGIN_SRC emacs-lisp
  (defun emacsmate-packages-installed-p ()
    "Are the emacsmate packages installed.  Lifted from emacs prelude."
    (loop for p in emacsmate-packages
          when (not (package-installed-p p)) do (return nil)
          finally (return t)))
  
  (defun emacsmate-package-dir (package)
    "Determines the package directory for PACKAGE"
    (let ((pkg-vec (cdr (assq package package-alist)))
          available-version found)
      ;; Check if PACKAGE is available in `package-alist'.
      (when pkg-vec
        (setq available-version (package-version-join (package-desc-vers pkg-vec)))
        (setq found (package--dir (symbol-name package) (format "%s" available-version))))
      (symbol-value 'found)))
  
  (defun emacsmate-package-load-path (package &optional subdirs)
    "Adds PACKAGE to the load path.  Optionally add subdirectories (SUBDIRS)"
    (let ((default-directory (emacsmate-package-dir package)))
      (when default-directory
        (if (not subdirs)
            (add-to-list 'load-path (emacsmate-package-dir package))
          (normal-top-level-add-subdirs-to-load-path)))
      (symbol-value 'default-directory)))
#+END_SRC
*** The emacsmate-coding-hook:
A single hook holding those functions which should be run in *every*
code buffer.

We have a number of turn-on-* functions since it's advised that lambda
functions not go in hooks. Repeatedly evaling an add-to-list with a
hook value will repeatedly add it since there's no way to ensure that
a lambda doesn't already exist in the list.

#+srcname: emacsmate-hook-functions
#+begin_src emacs-lisp
  (defun emacsmate-local-column-number-mode ()
    (make-local-variable 'column-number-mode)
    (column-number-mode t))
  
  (defun emacsmate-local-comment-auto-fill ()
    (set (make-local-variable 'comment-auto-fill-only-comments) t)
    (auto-fill-mode t))
  
  (defvar save-place nil)
  (defun emacsmate-turn-on-save-place-mode ()
    (setq save-place t))
  
  (defun emacsmate-turn-on-whitespace ()
    (whitespace-mode t))
  
  
  (defun emacsmate-turn-on-flyspell-prog-mode ()
    (flyspell-prog-mode))
  
  (defun emacsmate-turn-on-org-table-comment-mode ()
    (when (fboundp 'org-table-comment-mode)
      (org-table-comment-mode 1)))
  
#+end_src

#+srcname: emacsmate-add-local-column-number-mode
#+begin_src emacs-lisp
(add-hook 'emacsmate-coding-hook 'emacsmate-local-column-number-mode)
#+end_src

#+srcname: start-kit-add-local-comment-auto-fill
#+begin_src emacs-lisp
(add-hook 'emacsmate-coding-hook 'emacsmate-local-comment-auto-fill)
#+end_src

#+begin_src emacs-lisp
  (defun emacsmate-pretty-lambdas ()
    (font-lock-add-keywords
     nil `(("(\\(lambda\\>\\)"
            (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                      ,(make-char 'greek-iso8859-7 107))
                      nil))))))
#+end_src

#+srcname: emacsmate-add-pretty-lambdas
#+begin_src emacs-lisp
  (when (window-system)
    (add-hook 'emacsmate-coding-hook 'emacsmate-pretty-lambdas))
#+end_src

#+srcname: emacsmate-add-flyspell-prog-mode
#+begin_src emacs-lisp
  (add-hook 'emacsmate-coding-hook 'emacsmate-turn-on-flyspell-prog-mode)
#+end_src

#+srcname: emacsmate-run-emacsmate-coding-hook
#+begin_src emacs-lisp
(defun run-emacsmate-coding-hook ()
  "Enable things that are convenient across all coding buffers."
  (run-hooks 'emacsmate-coding-hook))
#+end_src
** Load Path, etc
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path emacsmate-dir)
  (defvar autoload-file (concat emacsmate-dir "loaddefs.el")
    "EmacsMate autoload file")
  (require 'package)
  (when (boundp 'package-user-dir)
    (setq package-user-dir (concat emacsmate-dir "elpa"
                                   (cond
                                    ((and (= emacs-major-version 24)
                                          (>= emacs-minor-version 3))
                                     "-24.3")
                                    (t "")))))
  
  (setq custom-file (concat emacsmate-dir "custom.el"))
  
#+END_SRC
** Ubiquitous Packages
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (with-no-warnings
    (require 'cl))
  (require 'saveplace)
  (require 'ffap)
  (require 'uniquify)
  (require 'ansi-color)
  (require 'recentf)
#+END_SRC

** Setting up ELPA
#+BEGIN_SRC emacs-lisp
  (setq package-archives
        '(("original"    . "http://tromey.com/elpa/")
          ("gnu"         . "http://elpa.gnu.org/packages/")
          ("marmalade"   . "http://marmalade-repo.org/packages/")
          ("melpa"       . "http://melpa.milkbox.net/packages/")))
  (package-initialize)
  (unless (emacsmate-packages-installed-p)
    (package-refresh-contents)
    (dolist (package emacsmate-packages)
      (message "Installing Package %s" package)
      (unless (package-installed-p package)
        (package-install package))))
#+END_SRC
** OS X bug
#+BEGIN_SRC emacs-lisp
(if (eq system-type 'darwin)
    (setq system-name (car (split-string system-name "\\."))))
#+END_SRC
** Auto-install
Instead of requiring that you use all the features, the features are
set up as you go using emacs lisp package archive.  The following
macro allows auto-installing of modes or packages:
#+BEGIN_SRC emacs-lisp
  (defmacro autoinstall (function package &optional docstring file)
    "Macro for auto-installing/auto-loading a particular package.
    FUNCTION is the function name
    PACKAGE is the package name
    DOCSTRING is the documentation string
    FILE is the file name of the load path"
    `(let ((fn ,file))       (if fn
           (progn
             (if (not (file-exists-p fn))
                 (unless (file-exists-p (concat fn ".el"))
                   (setq fn (format "%s/%s" (emacsmate-package-dir ',package) fn))
                   (if (not (file-exists-p fn))
                       (unless (file-exists-p (concat fn ".el"))
                         (setq fn nil)))))))
       (unless fn
         (setq fn (format "%s/%s" (emacsmate-package-dir ',package)
                          (symbol-name ',package)))
         (unless (file-exists-p (concat fn ".el"))
           (setq fn (format "%s/%s" (emacsmate-package-dir ',package)
                            (symbol-name ',function)))
           (unless (file-exists-p (concat fn ".el"))
             (setq fn nil))))
       (if (and fn (package-installed-p ',package))
           (progn
             (unless (or (fboundp ',function) (boundp ',function))
               (autoload ',function fn ,(or docstring
                                            (format "Install `%s' using package `%s'"
                                                    function package)) t))
             (if (file-exists-p (expand-file-name
                                 (format "EmacsMate-%s.org" (symbol-name ',package))
                                 emacsmate-dir))
                 (eval-after-load fn
                   (emacsmate-load-org (expand-file-name
                                        (format "EmacsMate-%s.org" (symbol-name ',package))
                                        emacsmate-dir))) nil))
         (defun ,function nil
           ,(concat (or docstring
                        (format "Install `%s' using package `%s'"
                                function package)) " (To be Installed)")
           (interactive)
           (unless (package-installed-p ',package)
             (package-install ',package))
           (if (file-exists-p (expand-file-name
                               (format "EmacsMate-%s.org" (symbol-name ',package))
                               emacsmate-dir))
               (emacsmate-load-org (expand-file-name
                                    (format "EmacsMate-%s.org" (symbol-name ',package))
                                    emacsmate-dir)))
           (call-interactively ',function)))))
  
  (defmacro autoinstall-ext (ext function package &optional docstring file)
    "Macro for auto-installing/auto-loading a particular package for a mode.
    EXT is the extension regular expression
    FUNCTION is the function name
    PACKAGE is the package name
    DOCSTRING is the documentation string
    FILE is the file name of the load path"
    `(progn
       (autoinstall ,function ,package ,docstring ,file)
       (add-to-list 'auto-mode-alist '(,ext . ,function))))
  
  (defvar emacsmate-autoinstall-extensions nil
    "Autoinstalled modes")
  (setq emacsmate-autoinstall-extensions
        '(("\\.[qsS]\\'" S-mode ess "lisp/ess-site")
          ("\\.[Rr]\\'" R-mode ess "lisp/ess-site")
          ("\\.[Rr][Dd]\\'" Rd-mode ess "lisp/ess-site")
          ("\\.[Ss][Aa][Ss]\\'" sas-mode ess "lisp/ess-site")
          ("\\.[Ss][Tt][Aa][Tt][Aa]\\'"  stata-mode ess "lisp/ess-site")
          ("\\.[RrSs][Nn][Ww]\\'" Rnw-mode ess "lisp/ess-site")
          ("\\.[Nn][Ss][Ii]\\'" nsis-mode nsis-mode)
          ("\\.[Mm][Uu][Ss][Ee]\\'" muse-mode muse)
          ("\\.[Uu][Mm][Ll]\\'" plantuml-mode plantuml-mode)
          ("\\.[Nn][Ss][Hh]\\'" nsis-mode nsis-mode)
          ("\\.[Pp][Hh][Pp]\\'" php-mode php-mode)
          ;; Visual Basic Mode
          ;; Csharp mode
          ("\\.[Cc][Ss]\\'" csharp-mode csharp-mode)
          ("\\.[Pp][Ss]1\\'" powershell-mode powershell-mode)
          ;; ntcmd mode
          ("\\.[Bb][Aa][Tt]\\'" ntcmd-mode ntcmd)
          ;; Autohotkey
          ;;
          ("\\.[Pp][Oo][Vv]\\'"  pov-mode pov-mode)
          ("\\.[Mm][Ll][iIYyLlPp]?\\'" tuareg-mode tuareg)
          
          ;;()
          ))
  ;; Powershell
  
  (defvar emacsmate-autoinstall-packages nil
    "Autoinstalled packages")
  
  (setq emacsmate-autoinstall-packages
        '((magit-status magit)
          (dictionary-search dictionary)
          (dictionary-match-words dictionary)
          (dictionary-lookup-definition dictionary)
          (dictionary dictionary)
          (dictionary-mous-popup-matching-words dictionary)
          (dictionary-popup-matching-words dictionary)
          (dictionary-tooltip-mode dictionary)
          (global-dictionary-tooltip-mode)
          (camldebug tuareg)
          (powershell powershell)
          (org-readme-sync org-readme)
          (textmate-to-yas textmate-to-yas)
          (R ess "lisp/ess-site")))
  (mapc
   (lambda(package)
     (condition-case err
         (progn
           (message "%s" (macroexpand `(autoinstall ,(nth 0 package) ,(nth 1 package) nil ,(nth 2 package))))
           (eval (macroexpand `(autoinstall ,(nth 0 package) ,(nth 1 package) nil ,(nth 2 package)))))
       (error (message "Error loading %s: %s" package err))))
   emacsmate-autoinstall-packages)
  
  (mapc
   (lambda(package)
     (condition-case err
         (eval (macroexpand `(autoinstall-ext ,(nth 0 package) ,(nth 1 package)
                                              ,(nth 2 package) nil ,(nth 3 package))))
       (error (message "Error loading %s: %s" package err))))
   emacsmate-autoinstall-extensions)
  
  ;;(message "%s" (macroexpand '(autoinstall magit-status magit)))
#+END_SRC
** Printing
:PROPERTIES:
:ID: 3484edff-15e3-47d5-85e5-76251d4b8776
:END:
This implements printing assuming:
- gtklp is installed and accessible or
- GSView/Ghostrcript is installed and accessible.
#+BEGIN_SRC emacs-lisp
  (defcustom emacsmate-paper-size "letter"
    "Paper size for Emacs Printing"
    :type 'string
    :group 'emacsmate)
  (with-no-warnings
    (if (executable-find "gtklp")
        (progn
          (setq ps-lpr-command (executable-find "gtklp")))
      (let ((gsprint (and (getenv "ProgramFiles")
                          (if (file-exists-p (format "%s/Ghostgum/gsview/gsprint.exe"
                                                     (getenv "ProgramFiles")))
                              (format "%s/Ghostgum/gsview/gsprint.exe"
                                      (getenv "ProgramFiles"))
                            nil))))
        (if (or gsprint (executable-find "gsprint"))
            (progn
              (setq-default ps-lpr-command (or gsprint (executable-find "gsprint")))
              (setq-default ps-printer-name t)
              (setq-default ps-printer-name-option nil)
              (setq ps-lpr-switches '("-query")) ; show printer dialog
              (setq ps-right-header '("/pagenumberstring load" ps-time-stamp-mon-dd-yyyy)))
          (when (executable-find "gswin32c")
            (setq ps-printer-name t)
            (setq ps-lpr-command (executable-find "gswin32c"))
            (setq ps-lpr-switches `("-q" "-dNOPAUSE" "-dBATCH"
                                    "-sDEVICE=mswinpr2"
                                    ,(format "-sPAPERSIZE=%s" emacsmate-paper-size))))))))
#+END_SRC
** Coding Hook

** Customize Settings
#+BEGIN_SRC emacs-lisp
(load custom-file 'noerror)
#+END_SRC
** Key Bindings
To use CUA-type keys and others, I use:
- Ergoemacs-key bingings, plus a bit extra
- CUA-mode
- org-cua-dwim to use CUA keys in org-mode.
- Smex

#+BEGIN_SRC emacs-lisp
  (autoload 'log-edit-mode "log-edit" "" t)
  (defun helm-smex-if-exists (&optional prefix-arg)
    (interactive "p")
    (if (fboundp 'helm-M-x)
        (helm-M-x )
      (if (fboundp 'smex)
          (smex)
        (execute-extended-command prefix-arg))))
  
  (global-set-key (kbd "C-x b") 'helm-mini)
  
  (when (emacsmate-package-load-path 'helm-projectile)
    (require 'helm-projectile))
  
  (defun emacsmate-follow-mode ()
    "Add follow mode to buffers and other types of things."
    (helm-attrset 'follow 1 helm-source-buffers-list)
    (helm-attrset 'follow 1 helm-source-moccur)
    (helm-attrset 'follow 1 helm-c-source-projectile-buffers-list))
  
  (add-hook 'helm-before-initialize-hook 'emacsmate-follow-mode)
  
  (defun emacsmate-multi-all ()
    "Multi-occur in all buffers (with files)"
    (interactive)
    (helm-multi-occur
     (delq nil
           (mapcar
            (lambda(b)
              (when (buffer-file-name b)
                (buffer-name b)))
            (buffer-list)))))
  
  (defun emacsmate-multi-projectile ()
    "Multi-occur in project buffers"
    (helm-multi-occur (helm-c-projectile-candidate-buffer-content)))
  
  (defun emacsmate-helm ()
    "Preconfigured `helm' lightweight version \(project -> buffer -> recentf\)."
    (interactive)
    (require 'helm-files)
    (require 'helm-projectile)
    (helm-other-buffer '(helm-c-source-projectile-buffers-list
                         helm-source-buffers-list
                         helm-c-source-projectile-files-list
                         helm-source-recentf
                         helm-source-buffer-not-found)
                       "*helm emacsmate*"))
  
  ;; (setq helm-before-initialize-hook nil)
  
  (setq helm-M-x-requires-pattern nil)
  
  (when (emacsmate-package-load-path 'ergoemacs-mode)
    (require 'ergoemacs-mode)
    (ergoemacs-key "M-a" 'helm-smex-if-exists "M-x")
    (ergoemacs-key "M-m" 'org-capture "Capture")
    (ergoemacs-key "M-M" 'org-agenda "Agenda")
    (ergoemacs-key "M-b" 'ace-jump-mode "Ace Jump")
    (require 'expand-region)
    (ergoemacs-key "M-8" 'er/expand-region
                   (format "%sregion%s"
                           (make-string 1 8592)
                           (make-string 1 8594)))
    
    (ergoemacs-key "M-9" 'er/contract-region
                   (format "%sregion%s"
                           (make-string 1 8594)
                           (make-string 1 8592)))
    (when (boundp 'expand-region-contract-fast-key)
      (setq expand-region-contract-fast-key (ergoemacs-kbd "7" t)))
    (when (boundp 'expand-region-reset-fast-key)
      (setq expand-region-reset-fast-key (ergoemacs-kbd "9" t)))
    (require 'multiple-cursors)
    (ergoemacs-key "M-*" 'mc/mark-next-like-this "Mark Next")
    (ergoemacs-key "M-&" 'mc/edit-lines "Edit Lines")
    (ergoemacs-key "M-;" 'emacsmate-multi-all "Helm moccur")
    (ergoemacs-key "M-:" 'emacsmate-multi-all "Prj moccur")
    (ergoemacs-setup-keys)
    (ergoemacs-mode 1)
    ;;
    (global-set-key "\C-x\C-c" 'ignore)
    (global-set-key "\C-x\C-z" 'ignore)
    (global-set-key (kbd "C-M-S-Q") 'save-buffers-kill-emacs))
  (cua-mode) 
  (org-cua-dwim-activate)
  
#+END_SRC
*** Additional Key Bindings
Help should allow apropos binding
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-h a") 'apropos)
#+END_SRC

** Popup right click menu from ergoemacs
This is the popup menu taken from ErgoEmacs
#+BEGIN_SRC emacs-lisp
  ;; Mouse wheel behavior
  (global-set-key [C-wheel-up] 'text-scale-increase)
  (global-set-key [C-wheel-down] 'text-scale-decrease)
  (global-set-key [C-down-mouse-2] 'text-scale-normal-size)
  
  ;; Right-click opens the context menu
  (global-set-key [mouse-3] 'emacsmate-context-menu)
  
  (defvar edit-popup-menu
    '(keymap
      (undo menu-item "Undo" undo
            :enable (and
                     (not buffer-read-only)
                     (not
                      (eq t buffer-undo-list))
                     (if
                         (eq last-command 'undo)
                         (listp pending-undo-list)
                       (consp buffer-undo-list)))
            :help "Undo last operation"
            :keys "Ctrl+Z")
      (separator-undo menu-item "--")
      (cut menu-item "Cut" clipboard-kill-region
           :help "Delete text in region and copy it to the clipboard"
           :keys "Ctrl+X")
      (copy menu-item "Copy" clipboard-kill-ring-save
            :help "Copy text in region to the clipboard"
            :keys "Ctrl+C")
      (paste menu-item "Paste" clipboard-yank
             :help "Paste text from clipboard"
             :keys "Ctrl+V")
      (paste-from-menu menu-item "Paste from Kill Menu" yank-menu
                       :enable (and
                                (cdr yank-menu)
                                (not buffer-read-only))
                       :help "Choose a string from the kill ring and paste it")
      (clear menu-item "Clear" delete-region 
             :enable (and mark-active (not buffer-read-only))
             :help "Delete the text in region between mark and current position"
             :keys "Del")
      (separator-select-all menu-item "--")
      (mark-whole-buffer menu-item "Select All" mark-whole-buffer
                         :help "Mark the whole buffer for a subsequent cut/copy")))
  
  (defun emacsmate-context-menu (event)
    "Pop up a context menu."
    (interactive "e")
    (popup-menu edit-popup-menu))
  
    
#+END_SRC
** Default Package/Modes Setup
*** Auto-indent-mode
The autoindent package is something that I find quite useful.  I also
like to insert some TextMate behaviors to my keys.
#+BEGIN_SRC emacs-lisp
  (with-no-warnings
    (setq auto-indent-key-for-end-of-line-then-newline "<M-return>")
    (setq auto-indent-key-for-end-of-line-insert-char-then-newline "<M-S-return>")
    (setq auto-indent-kill-line-at-eol nil)
    (setq auto-indent-delete-line-char-remove-extra-spaces t))
  
  (when (fboundp 'auto-indent-global-mode)
    (auto-indent-global-mode))
#+END_SRC
*** Auto-complete mode
Auto complete mode setup
#+BEGIN_SRC emacs-lisp
  (when (emacsmate-package-load-path 'auto-complete)
    (require 'auto-complete-config)
    (ac-config-default))
#+END_SRC 
**** Show menu
#+BEGIN_SRC emacs-lisp
  (when (boundp 'ac-auto-show-menu)
    (setq ac-auto-show-menu t))
  (when (boundp 'ac-auto-start)
    (setq ac-auto-start 2))
  (when (boundp 'ac-delay)
    (setq ac-delay 0))
  
  
  
#+END_SRC
**** Finish completion by tab
#+BEGIN_SRC emacs-lisp
  (when (boundp 'ac-completing-map)
    (define-key ac-completing-map "\t" 'ac-complete)
    (define-key ac-completing-map "\r" nil))
  
#+END_SRC
**** Ignore case
#+BEGIN_SRC emacs-lisp
  (when (boundp 'ac-ignore-case)
    (setq ac-ignore-case 'smart))
#+END_SRC
**** Pos Tip for "beautiful" tips
#+BEGIN_SRC emacs-lisp
  (when (emacsmate-package-load-path 'pos-tip)
    (require 'pos-tip)
    (when (eq system-type 'windows-nt)
      (condition-case err
          (when (= 23 emacs-major-version)
            (pos-tip-w32-max-width-height nil))
        (error (message "Error in postip")))))
#+END_SRC
*** Bookmarks
:PROPERTIES:
:ID: 2c39ce29-8541-4cd3-9715-ec0f0d368eb1
:END:
Using M$ visual studio style bookmarks:
#+BEGIN_SRC emacs-lisp
  (autoinstall bm-toggle bm "Toggle Bookmarks in current buffer")
  (autoinstall bm-toggle-mouse bm "Toggle Bookmarks in current buffer")
  
  (autoinstall bm-next bm "Goto bookmark")
  (autoinstall bm-next-mouse bm "Goto bookmark")
  
  (autoinstall bm-previous bm "Goto previous bookmark")
  (autoinstall bm-previous-mouse bm "Goto previous bookmark")
  (global-set-key (kbd "<left-fringe> <mouse-5>") 'bm-next-mouse)
  (global-set-key (kbd "<left-fringe> <mouse-4>") 'bm-previous-mouse)
  (global-set-key (kbd "<left-fringe> <mouse-1>") 'bm-toggle-mouse)
  
  
  (global-set-key (kbd "<C-f2>") 'bm-toggle)
  (global-set-key (kbd "<f2>")   'bm-next)
  (global-set-key (kbd "<S-f2>") 'bm-previous)
#+END_SRC

To setup the right-fringe functionality you would use:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<left-fringe> <mouse-5>") 'bm-next-mouse)
  (global-set-key (kbd "<left-fringe> <mouse-4>") 'bm-previous-mouse)
  (global-set-key (kbd "<left-fringe> <mouse-1>") 'bm-toggle-mouse)
  (when (boundp 'bm-marker)
    (setq bm-marker 'bm-marker-right))
#+END_SRC

*** Emacs Lisp
:PROPERTIES:
:CUSTOM_ID: emacs-lisp
:END:
This does the following:
- Turn on el-doc
- Turn on coding hook
- Removes =.elc= files on save.
- Add =C-c v= to be `eval-buffer'
- Changes adaptive filling for lisp-style comments
#+begin_src emacs-lisp
  
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'emacs-lisp-mode-hook 'run-emacsmate-coding-hook)
  (add-hook 'emacs-lisp-mode-hook 'emacsmate-remove-elc-on-save)
  ;; (add-hook 'emacs-lisp-mode-hook 'idle-highlight)
  (define-key emacs-lisp-mode-map (kbd "C-c v") 'eval-buffer)
  
  
  
  
  (defun emacsmate-remove-elc-on-save ()
    "If you're saving an elisp file, likely the .elc is no longer valid."
    (make-local-variable 'after-save-hook)
    (add-hook 'after-save-hook
              (lambda ()
                (if (file-exists-p (concat buffer-file-name "c"))
                    (delete-file (concat buffer-file-name "c"))))))
  
    
#+end_src

**** Paste Diffs

When pasting diffs that start entirely with +, take out the initial +
Also take off unnecessary ">" and "+" for example copying:

#+BEGIN_SRC emacs-lisp
  (defun emacsmate-emacs-lisp-fix-diff (beg end)
    "Fixes ess path"
    (save-restriction
      (save-excursion
        (save-match-data
          (narrow-to-region beg end)
          (goto-char (point-min))
          (while (re-search-forward "^[ \t]*[+][ \t]+" nil t)
            (replace-match ""))))))
  
  (defun emacsmate-emacs-lisp-turn-on-fix-diff ()
    (interactive)
    (when (and (boundp 'ess-language) (string= "S" ess-language))
      (add-hook 'auto-indent-after-yank-hook 'emacsmate-emacs-lisp-fix-diff t t)))
  (add-hook 'emacs-lisp-mode-hook 'emacsmate-emacs-lisp-turn-on-fix-diff)
  
#+END_SRC
*** Ido Mode
ido-mode is like magic pixie dust!


The [[http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/][Introduction to Ido Mode]] provides a nice introduction and
explanation of these customizations.

#+srcname: emacsmate-loves-ido-mode
#+begin_src emacs-lisp 
  (when (> emacs-major-version 21)
    (ido-mode t)
    (mapc (lambda(ext)
            (add-to-list 'completion-ignored-extensions ext))
          '("elc" "exe" "com" "org_archive" "png" "gif" "csv" "jpg" "jpeg"))
    (ido-ubiquitous 1)
    (setq ido-enable-prefix t
          ido-enable-flex-matching t
          ido-create-new-buffer 'always
          ido-use-filename-at-point nil
          ido-enable-tramp-completion t
          ido-everywhere t
          org-completion-use-ido t
          ido-max-prospects 10
          ido-use-virtual-buffers t
          ido-default-file-method 'selected-window
          ido-ignore-extensions t
          ido-file-extensions-order '(".org" ".R" ".ctl" ".pltc" ".nsi" ".txt" ".py" ".emacs" ".xml" ".el" ".ini" ".cfg" ".cnf" ".nsi" ".nsh")))
  
#+end_src

See http://www.emacswiki.org/emacs/InteractivelyDoThings
**** Display Completions Vertically
I like the look.  I don't like the arrow keys not doing what I expect
(changed with ergoemacs)
#+BEGIN_SRC emacs-lisp
  (setq ido-decorations (quote ("\n-> " "" "\n   " "\n   ..." "[" "]" " [No match]" " [Matched]" " [Not readable]" " [Too big]" " [Confirm]")))
  
  (defun ido-disable-line-trucation () (set (make-local-variable 'truncate-lines) nil))
  (add-hook 'ido-minibuffer-setup-hook 'ido-disable-line-trucation)
#+END_SRC


**** Preventing auto-searches unless called explicitly
#+BEGIN_SRC emacs-lisp
  ;; disable auto searching for files unless called explicitly
  (setq ido-auto-merge-delay-time 99999)
  
  (define-key ido-file-dir-completion-map (kbd "C-c C-s") 
    (lambda() 
      (interactive)
      (ido-initiate-auto-merge (current-buffer))))
#+END_SRC

*** Scheme
:PROPERTIES:
:CUSTOM_ID: scheme
:END:

#+begin_src emacs-lisp
(add-hook 'scheme-mode-hook 'run-emacsmate-coding-hook)
;; (add-hook 'scheme-mode-hook 'idle-highlight)
(font-lock-add-keywords 'scheme-mode
			'(("(\\|)" . 'emacsmate-paren-face)))
#+end_src

*** Recent Files
#+BEGIN_SRC emacs-lisp
(recentf-mode 1) 
#+END_SRC

*** Yasnippet
#+BEGIN_SRC emacs-lisp
  (when (emacsmate-package-load-path 'textmate-to-yas)
    (require 'textmate-to-yas))
  (yas-global-mode)
  (when (not (file-exists-p (expand-file-name "snippets" emacsmate-dir)))
    (make-directory (expand-file-name "snippets" emacsmate-dir)))
  
  (yas-load-directory (expand-file-name "snippets" emacsmate-dir))
  
  (defun yas-org-very-safe-expand ()
    (let ((yas-fallback-behavior 'return-nil)) (yas-expand)))
  
  (defun yas-org-setup ()
    ;; yasnippet (using the new org-cycle hooks)
    (when (boundp 'yas-trigger-key)
      (set (make-local-variable 'yas-trigger-key) [tab]))
    (when (boundp 'org-tab-first-hook)
      (add-to-list 'org-tab-first-hook 'yas-org-very-safe-expand))
    (when (boundp 'yas-keymap)
      (define-key yas-keymap [tab] 'yas-next-field)))
  
  (when (boundp 'org-mode-hook)
    (add-hook 'org-mode-hook #'yas-org-setup))
#+END_SRC

*** Org-mode
Org mode setup is in a separate file
#+BEGIN_SRC emacs-lisp
  (emacsmate-load-org
   (expand-file-name "emacsmate-org.org" emacsmate-dir))
#+END_SRC
*** SSH
Make plinkx the default method on windows.  I have had less problems
with this method.
#+BEGIN_SRC emacs-lisp
  (when (and (eq system-type 'windows-nt) (executable-find "plink"))
    (with-no-warnings
      (setq ssh-program (executable-find "plink")))
    (setq tramp-default-method "plinkx")
    (defun plinkx (session)
      "Connects to a saved plink session"
      (interactive (list (read-from-minibuffer "Saved Session: ")))
      (ssh (concat "-load " session) (concat "*" session "*"))
      (message "%s" session)))
  
#+END_SRC

*** Whitespace mode
#+BEGIN_SRC emacs-lisp
  ;; Taken from ergoemacs
  (with-no-warnings
    (defun toggle-whitespace-setting ()
      "Toggle some display settings for `whitespace-mode'."
      (interactive)
      (let (stateBefore stateAfter (statesList '(0 1)))
        (setq stateBefore (if (get 'toggle-whitespace-setting 'state) (get 'toggle-whitespace-setting 'state) (elt statesList 0)))
        (setq stateAfter (% (+ stateBefore (length statesList) 1) (length statesList)))
        (put 'toggle-whitespace-setting 'state stateAfter)
        (cond
         ((equal stateAfter 0)
          (progn
            (when (boundp 'whitespace-style)
              (setq whitespace-style '(tabs spaces trailing lines space-before-tab newline indentation empty space-after-tab space-mark tab-mark newline-mark)))
            (when (boundp 'whitespace-display-mappings)
              (setq whitespace-display-mappings
                    '((space-mark 32 [183] [46])
                      (space-mark 160 [164] [95])
                      (space-mark 2208 [2212] [95])
                      (space-mark 2336 [2340] [95])
                      (space-mark 3616 [3620] [95])
                      (space-mark 3872 [3876] [95])
                      (newline-mark 10 [36 10])
                      (tab-mark 9 [187 9] [92 9]))))
            (message "whitespace-setting set to default.")))
         ((equal stateAfter 1)
          (progn
            ;; Make whitespace-mode with very basic background coloring for whitespaces
            (setq whitespace-style '( spaces tabs newline space-mark tab-mark newline-mark ))
            
            ;; Make whitespace-mode and whitespace-newline-mode use paragraph for end of line char and triangle for tab.
            (setq whitespace-display-mappings
                  '(
                    (space-mark 32 [183] [46]) ; normal space, MIDDLE DOT, FULL STOP.
                    (space-mark 160 [164] [95])
                    (space-mark 2208 [2212] [95])
                    (space-mark 2336 [2340] [95])
                    (space-mark 3616 [3620] [95])
                    (space-mark 3872 [3876] [95])
                    (newline-mark 10 [182 10]) ; newlne
                    (tab-mark 9 [9655 9] [92 9]) ; tab
                    )) 
            (message "whitespace-setting set to using %s for tab and %s for newline."
                     (make-string 1 9655) (make-string 1 182)))))
        
        (when (and (boundp 'global-whitespace-mode) global-whitespace-mode)
          (global-whitespace-mode 0) (global-whitespace-mode 1))
        (when (and (boundp 'whitespace-mode) whitespace-mode)
          (whitespace-mode 0) (whitespace-mode 1))
        
        ))
    (with-no-warnings
    ;; Make whitespace-mode with very basic background coloring for whitespaces.
    ;; http://ergoemacs.org/emacs/whitespace-mode.html
    (setq whitespace-style (quote ( spaces tabs newline space-mark tab-mark newline-mark )))
    
    ;; Make whitespace-mode and whitespace-newline-mode use paragraph marks for end of line char and triangles for for tab.
    (setq whitespace-display-mappings
          ;; all numbers are unicode codepoint in decimal. e.g. (insert-char 182 1)
          '(
            (space-mark 32 [183] [46]) ; SPACE 32, 183 MIDDLE DOT, 46 FULL STOP
            (newline-mark 10 [182 10]) ; LINE FEED, 
            (tab-mark 9 [9655 9] [92 9]) ; tab
            ))))
#+END_SRC
*** Perl
Use Cperl instead of perl-mode
#+BEGIN_SRC emacs-lisp
  ;; use cperl-mode instead of perl-mode
  (setq auto-mode-alist (rassq-delete-all 'perl-mode auto-mode-alist))
  (add-to-list 'auto-mode-alist '("\\.\\(p\\([lm]\\)\\)\\'" . cperl-mode))
  (setq interpreter-mode-alist (rassq-delete-all 'perl-mode interpreter-mode-alist))
  (add-to-list 'interpreter-mode-alist '("perl" . cperl-mode))
  (add-to-list 'interpreter-mode-alist '("perl5" . cperl-mode))
  (add-to-list 'interpreter-mode-alist '("miniperl" . cperl-mode))
#+END_SRC
*** Dired+
#+BEGIN_SRC emacs-lisp
  (when (emacsmate-package-load-path 'dired+)
    (require 'dired+))
#+END_SRC
*** Info+

*** Undo Tree
#+BEGIN_SRC emacs-lisp
  (when (emacsmate-package-load-path 'undo-tree)
    (require 'undo-tree)
    (global-undo-tree-mode))
#+END_SRC

*** Extend Drag and Drop
Drag and Drop Extend
#+BEGIN_SRC emacs-lisp
  (when (emacsmate-package-load-path 'extend-dnd)
    (require 'extend-dnd)
    (extend-dnd-activate))
#+END_SRC

** Mode Line Changes
Based off of
http://amitp.blogspot.com/2011/08/emacs-custom-mode-line.html

I have found this makes emacs slow.  I have commented it out.
#+BEGIN_SRC emacs-lisp
  ;; Mode line setup
  (when (and t (emacsmate-package-load-path 'powerline))
    (require 'powerline)
    
    (defun powerline-emacsmate-theme ()
      "Setup a default mode-line."
      (interactive)
      (setq-default mode-line-format
                    '("%e"
                      (:eval
                       (let* ((active (powerline-selected-window-active))
                              (mode-line (if active 'mode-line 'mode-line-inactive))
                              (face1 (if active 'powerline-active1
                                       'powerline-inactive1))
                              (face2 (if active 'powerline-active2
                                       'powerline-inactive2))
                              (separator-left
                               (intern (format "powerline-%s-%s"
                                               powerline-default-separator
                                               (car powerline-default-separator-dir))))
                              (separator-right
                               (intern (format "powerline-%s-%s"
                                               powerline-default-separator
                                               (cdr powerline-default-separator-dir))))
                              (lhs (list
                                    (powerline-raw "%*" face1 'l)
                                    (powerline-buffer-size face1 'l)
                                    
                                    (powerline-raw mode-line-mule-info face1 'l)
                                    (powerline-raw (condition-case err
                                                       (concat (car (funcall tabbar-buffer-groups-function)) " ")
                                                     (error "Error ")) face1 'l)
                                    
                                    (funcall separator-left face1 mode-line)
                                    
                                    (powerline-buffer-id nil 'l)
                                    
                                    (when which-function-mode
                                      (concat
                                       " ["
                                       (powerline-which-func 'which-func nil)
                                       "]"))
                                    
                                    
                                    (powerline-raw " ")
                                    (funcall separator-left mode-line face1)
                                    
                                    (when (boundp 'erc-modified-channels-object)
                                      (powerline-raw erc-modified-channels-object
                                                     face1 'l))
                                    
                                    (powerline-major-mode face1 'l)
                                    
                                    (powerline-raw " " face1)
                                    
                                    (powerline-process face1)
                                    (powerline-minor-modes face1 nil)
                                    (powerline-narrow face1 'l)
                                    
                                    (powerline-raw " " face1)
                                    (funcall separator-left face1 face2)
                                    
                                    (powerline-vc face2 'r)))
                              (rhs (list
                                    (powerline-raw global-mode-string face2 'r)
                                    
                                    (funcall separator-right face2 face1)
                                    
                                    (powerline-raw "%4l" face1 'l)
                                    (powerline-raw ":" face1 'l)
                                    (powerline-raw "%3c" face1 'r)
                                    
                                    (funcall separator-right face1 mode-line)
                                    (powerline-raw " ")
                                    
                                    (powerline-raw "%6p" nil 'r)
                                    
                                    (powerline-hud face2 face1))))
                         ;;(message "%s %s" separator-left (funcall 'powerline-wave-left mode-line face1))
                         (concat
                          (powerline-render lhs)
                          (powerline-fill face2 (powerline-width rhs))
                          (powerline-render rhs)))))))
    
    (setq powerline-default-separator 'arrow-fade)
    ;;(diminish 'auto-fill-mode "")
    (powerline-emacsmate-theme))
  (defun emacsmate-diminish ()
    "Removes minor modes that are not that exciting..."
    (interactive)
    (condition-case err (diminish 'projectile-mode "") (error nil))
    (condition-case err (diminish 'undo-tree-mode "") (error nil))
    (condition-case err (diminish 'yas-minor-mode "") (error nil))
    (condition-case err (diminish 'auto-indent-mode "") (error nil))
    (condition-case err (diminish 'auto-complete-mode "") (error nil))
    (condition-case err (diminish 'flyspell-mode "") (error nil))
    (condition-case err (diminish 'eldoc-mode "") (error nil))
    (condition-case err (diminish 'org-indent-mode "") (error nil))
    (condition-case err (diminish 'golden-ratio-mode "") (error nil))
    (condition-case err (diminish 'iimage-mode "")  (error nil)))
  (add-hook 'emacs-startup-hook 'emacsmate-diminish)
  
#+END_SRC

#+RESULTS:

** Menu Changes
This is taken from ErgoEmacs

#+BEGIN_SRC emacs-lisp
  ;; the purpose of this file is to create a more clean menu.
  ;; Rationale:
  ;; - Emacs's Menu Usability Problem
  ;;   http://ergoemacs.org/emacs/modernization_menu.html
  
  
  ;; File menu
  (setq menu-bar-file-menu
        '(keymap
          (new-file menu-item "New" ergoemacs-new-empty-buffer)
          (make-frame menu-item "New Frame" make-frame-command)
          (open-file menu-item "Open..." find-file)
          (open-last-closed menu-item "Open last closed" ergoemacs-open-last-closed)
          (kill-buffer menu-item "Close" ergoemacs-close-current-buffer)
          (separator1 menu-item "--")
          (save-buffer menu-item "Save" save-buffer)
          (write-file menu-item "Save As..." write-file)
          (revert-buffer menu-item "Revert to Saved" revert-buffer)
          (separator2 menu-item "--")
          (lang-modes menu-item "Language Modes"
                      (keymap (c "C" . c-mode)
                              (c++ "C++" . c++-mode)
                              (csharp "C#" . csharp-mode)
                              (java "Java" . java-mode)
                              (separator3 "--")
                              (css "CSS" . css-mode)
                              (html "HTML" . html-mode)
                              (nxml "XML (nxml-mode)" . nxml-mode)
                              (xml "XML (xml-mode)" . xml-mode)
                              (js "Javascript (js-mode)" . js-mode)
                              (js2 "Javascript (js2-mode)" . js2-mode)
                              (latex "LaTeX" . latex-mode)
                              (separator2 "--")
                              (elisp "Emacs Lisp" . emacs-lisp-mode)
                              (clojure "Clojure" . clojure-mode)
                              (ocaml "OCaml" . tuareg-mode)
                              (haskell "Haskell" . haskell-mode)
                              (scala-mode "Scala" . scala-mode)
                              (haskell "Erlang" . erlang-mode)
                              (separator1 "--")
                              (perl "Perl" . cperl-mode)
                              (php "PHP" . php-mode)
                              (python "Python" . python-mode)
                              (ruby "Ruby" . ruby-mode)
                              (tcl "TCL" . tcl-mode)
                              (bash "Bash" . sh-mode)
                              (vb "Visual Basic" . visual-basic-mode)
                              (cmd "cmd.exe" . ntcmd-mode)
                              (powershell "PowerShell" . powershell-mode)
                              (list-text-editing-modes "List Text Editing Modes..." . list-text-editing-modes)
                              "major modes"))
          (separator3 menu-item "--")
          (print-buffer menu-item "Print" print-buffer)
          (ps-print-buffer-faces menu-item "Print (font+color)" ps-print-buffer-faces)
          (separator4 menu-item "--")
          (split-window menu-item "Split Window"
                        split-window-vertically)
          (split-window-leftright menu-item "Split Window left/right"
                                  split-window-horizontally
                                  :keys "Alt+Shift+2")
          (one-window menu-item "Unsplit Window"
                      delete-other-windows)
          (separator5 menu-item "--")
          (exit-emacs menu-item "Quit" save-buffers-kill-emacs)
          "File"))
  
  (define-key global-map [menu-bar file] (cons "File" menu-bar-file-menu))
  
  
  ;; Edit menu
  (setq menu-bar-edit-menu
        '(keymap
          (undo menu-item "Undo" undo
                :enable (and
                         (not buffer-read-only)
                         (not
                          (eq t buffer-undo-list))
                         (if
                             (eq last-command 'undo)
                             (listp pending-undo-list)
                           (consp buffer-undo-list)))
                :help "Undo last operation"
                :keys "Ctrl+Z")
          (redo menu-item "Redo" redo
                :keys "Ctrl+Shift+Z")
          (redo-sep menu-item "--")
          (cut menu-item "Cut" clipboard-kill-region
               :help "Delete text in region and copy it to the clipboard"
               :keys "Ctrl+X")
          (copy menu-item "Copy" clipboard-kill-ring-save
                :help "Copy text in region to the clipboard"
                :keys "Ctrl+C")
          (paste menu-item "Paste" clipboard-yank
                 :help "Paste text from clipboard"
                 :keys "Ctrl+V")
          (paste-from-menu menu-item "Paste from Kill Menu" yank-menu
                           :enable (and
                                    (cdr yank-menu)
                                    (not buffer-read-only))
                           :help "Choose a string from the kill ring and paste it")
          (clear menu-item "Clear" delete-region 
                 :enable (and mark-active (not buffer-read-only))
                 :help "Delete the text in region between mark and current position"
                 :keys "Del")
          (mark-whole-buffer menu-item "Select All" mark-whole-buffer
                             :help "Mark the whole buffer for a subsequent cut/copy")
          (separator-search menu-item "--")
          (search menu-item "Search"
                  (keymap
                   (search-forward menu-item "Text..." search-forward)
                   (separator-repeat-search menu-item "--")
                   (tags-srch menu-item "Search Tagged Files..." tags-search
                              :help "Search for a regexp in all tagged files")
                   (tags-continue menu-item "Continue Tags Search" tags-loop-continue
                                  :help "Continue last tags search operation")
                   "Search"))
          (i-search menu-item "Incremental Search"
                    (keymap
                     (isearch-forward menu-item "Forward String..." isearch-forward
                                      :help "Search forward for a string as you type it")
                     (isearch-backward menu-item "Backward String..." isearch-backward
                                       :help "Search backwards for a string as you type it")
                     (isearch-forward-regexp menu-item "Forward Regexp..." isearch-forward-regexp
                                             :help "Search forward for a regular expression as you type it")
                     (isearch-backward-regexp menu-item "Backward Regexp..." isearch-backward-regexp
                                              :help "Search backwards for a regular expression as you type it")
                     "Incremental Search"))
          (replace menu-item "Replace"
                   (keymap
                    (query-replace menu-item "Replace String..." query-replace 
                                   :enable (not buffer-read-only)
                                   :help "Replace string interactively, ask about each occurrence")
                    (query-replace-regexp menu-item "Replace Regexp..." query-replace-regexp 
                                          :enable (not buffer-read-only)
                                          :help "Replace regular expression interactively, ask about each occurrence")
                    (separator-replace-tags menu-item "--")
                    (tags-repl menu-item "Replace in Tagged Files..." tags-query-replace
                               :help "Interactively replace a regexp in all tagged files")
                    (tags-repl-continue menu-item "Continue Replace" tags-loop-continue
                                        :help "Continue last tags replace operation")
                    "Replace"))
          (goto menu-item "Go To"
                (keymap
                 (go-to-line menu-item "Goto Line..." goto-line
                             :help "Read a line number and go to that line")
                 (separator-tags menu-item "--")
                 (find-tag menu-item "Find Tag..." find-tag
                           :help "Find definition of function or variable")
                 (find-tag-otherw menu-item "Find Tag in Other Window..." find-tag-other-window
                                  :help "Find function/variable definition in another window")
                 (next-tag menu-item "Find Next Tag" menu-bar-next-tag
                           :enable (and
                                    (boundp 'tags-location-ring)
                                    (not
                                     (ring-empty-p tags-location-ring)))
                           :help "Find next function/variable matching last tag name")
                 (next-tag-otherw menu-item "Next Tag in Other Window" menu-bar-next-tag-other-window 
                                  :enable (and
                                           (boundp 'tags-location-ring)
                                           (not
                                            (ring-empty-p tags-location-ring)))
                                  :help "Find next function/variable matching last tag name in another window")
                 (apropos-tags menu-item "Tags Apropos..." tags-apropos
                               :help "Find function/variables whose names match regexp")
                 (separator-tag-file menu-item "--")
                 (set-tags-name menu-item "Set Tags File Name..." visit-tags-table
                                :help "Tell Tags commands which tag table file to use")
                 "Go To"))
          (bookmark menu-item "Bookmarks" menu-bar-bookmark-map)
          (separator-bookmark menu-item "--")
          (fill menu-item "Fill" fill-region
                :enable (and mark-active
                             (not buffer-read-only))
                :help "Fill text in region to fit between left and right margin")
          (props menu-item "Text Properties" facemenu-menu)
          "Edit"))
  
  (define-key global-map [menu-bar edit] (cons "Edit" menu-bar-edit-menu))
  
  
  ;; Options menu
  
                                          ; remove stuff
  (define-key menu-bar-options-menu [cua-mode] nil)
  (define-key menu-bar-options-menu [transient-mark-mode] nil)
  
  (define-key menu-bar-options-menu [cursor-separator] nil)
  (define-key menu-bar-options-menu [blink-cursor-mode] nil)
  (define-key menu-bar-options-menu [debugger-separator] nil)
  (define-key menu-bar-options-menu [debug-on-error] nil)
  (define-key menu-bar-options-menu [debug-on-quit] nil)
  
  (define-key menu-bar-options-menu [showhide showhide-tool-bar] nil)
  (define-key menu-bar-options-menu [showhide showhide-scroll-bar] nil)
  (define-key menu-bar-options-menu [showhide showhide-fringe] nil)
  
  (define-key menu-bar-options-menu [showhide mac-font-panel-mode] nil)
  (define-key menu-bar-options-menu [showhide showhide-battery] nil)
  (define-key menu-bar-options-menu [showhide datetime-separator] nil)
  (define-key menu-bar-options-menu [showhide showhide-date-time] nil)
  (define-key menu-bar-options-menu [showhide size-indication-mode] nil)
  
  ;; (define-key menu-bar-options-menu [customize] nil)
  ;; (define-key menu-bar-options-menu [save] nil)
  (define-key global-map (kbd "<S-down-mouse-1>") nil) ; remove Shift+Mouse Left Button for setting font
  
  ;; add a menu for showing line numbers on margin
  (define-key-after menu-bar-options-menu [showhide global-linum-mode]
    '(menu-item "Show/Hide line numbers in margin" global-linum-mode
                :button (:toggle . global-linum-mode))  'line-number-mode )
  
  ;; add a menu for toggling the visibility of spaces and tabs
  (define-key-after menu-bar-options-menu [showhide global-whitespace-mode]
    '(menu-item "Show/Hide whitespaces" global-whitespace-mode
                :button (:toggle . global-whitespace-mode)) 'line-number-mode )
  
  ;; add a menu to toggle whether down arrow key move cursor by visual line.
  (define-key-after menu-bar-options-menu [line-move-visual]
    '(menu-item "Move through wrapped lines" toggle-line-move-visual
                :button (:toggle . line-move-visual)) 'line-wrapping)
  
  ;; add a menu to toggle whether left/right cursor movement will move into camelCaseWords 
  (define-key-after menu-bar-options-menu [global-subword-mode]
    '(menu-item "Move through camelCaseWord" global-subword-mode
                :button (:toggle . global-subword-mode)) 'line-move-visual)
  
  ;; add font scale change
  (define-key-after menu-bar-options-menu [menu-font-size]
    '(menu-item "Font Size"
                (keymap 
                 (zoom-in menu-item "Zoom In" text-scale-increase)
                 (zoom-out menu-item "Zoom Out" text-scale-decrease)
                 (zoom-reset menu-item "Zoom Reset" text-scale-normal-size)))
    'menu-set-font)
  
  
  ;; Buffer menu
  (defun ergoemacs-update-buffers (&optional force)
    (define-key global-buffers-menu-map [next-buffer]
      '(menu-item "Next User Buffer" next-user-buffer             :keys "Ctrl+PgDn"))
    (define-key global-buffers-menu-map [previous-buffer]
      '(menu-item "Previous User Buffer" previous-user-buffer     :keys "Ctrl+PgUp"))
    (define-key-after global-buffers-menu-map [next-emacs-buffer]
      '(menu-item "Next Emacs Buffer" next-emacs-buffer           :keys "Ctrl+Shift+PgDn")
      'previous-buffer)
    (define-key-after global-buffers-menu-map [previous-emacs-buffer]
      '(menu-item "Previous Emacs Buffer" previous-emacs-buffer   :keys "Ctrl+Shift+PgUp")
      'next-emacs-buffer)
    (define-key global-buffers-menu-map [select-named-buffer] nil)
    (define-key global-buffers-menu-map [list-all-buffers]
      '(menu-item "List All Buffers" ibuffer                      :keys "Ctrl+X Ctrl+B"))
    )
  
  (add-hook 'menu-bar-update-hook 'ergoemacs-update-buffers t)
  
  
  ;; Tools menu
  
  (define-key menu-bar-tools-menu [shell]
    '("Shell" keymap
      (shell menu-item "Run Command..." shell-command
             :help "Invoke a shell command and catch its output")
      (shell-on-region menu-item "Run Command on Region..." shell-command-on-region
                       :enable mark-active
                       :help "Pass marked region to a shell command")
      (shell-sep1 menu-item "--")
      (cmd menu-item "Cmd" cmd-shell :help "Start Windows Shell (cmd.exe / command.com)")
      (eshell menu-item "Eshell" eshell :help "Start Emacs Shell")
      (msys menu-item "MSYS Shell" msys-shell :help "Start MSYS shell (sh.exe)")
      (shell-sep2 menu-item "--")
      (powershell menu-item "Powershell" powershell :help "Start PowerShell")
      "shells"))
  
  (define-key menu-bar-tools-menu [shell-on-region] nil)
  
  (define-key menu-bar-tools-menu [gnus] nil)
  (define-key menu-bar-tools-menu [rmail] nil)
  (define-key menu-bar-tools-menu [compose-mail] nil)
  (define-key menu-bar-tools-menu [separator-games] nil)
  (define-key menu-bar-tools-menu [games] nil)
  
  ;; obsolete, outdated contents. Much replaced by web.
  (define-key menu-bar-help-menu [getting-new-versions] nil)
  (define-key menu-bar-help-menu [describe-distribution] nil)
  
  (define-key menu-bar-help-menu [external-packages] nil)
  (define-key menu-bar-help-menu [more] nil)
  
  (define-key menu-bar-help-menu [emacs-known-problems] nil)
  (define-key menu-bar-help-menu [emacs-problems] nil)
  (define-key menu-bar-help-menu [find-emacs-packages] nil)
  
  ;; outdated humor and tech
  (define-key menu-bar-help-menu [eliza] nil)
  (define-key menu-bar-help-menu [emacs-psychotherapist] nil)
  
  ;; antiquated tutorial. If it needs a tutorial, something is wrong with UI.
  (define-key menu-bar-help-menu [emacs-tutorial] nil)
  (define-key menu-bar-help-menu [emacs-tutorial-language-specific] nil)
  (define-key menu-bar-help-menu [emacs-faq] nil)
  (define-key menu-bar-help-menu [search-documentation emacs-terminology] nil)
  
  ;; remove FSF propaganda. (already linked in About Emacs)
  (define-key menu-bar-help-menu [about-gnu-project] nil)
  (define-key menu-bar-help-menu [describe-copying] nil)
  (define-key menu-bar-help-menu [describe-no-warranty] nil)
  (define-key menu-bar-help-menu [more-manuals order-emacs-manuals] nil)
  (define-key menu-bar-help-menu [manuals order-emacs-manuals] nil)
  (define-key menu-bar-help-menu [sep2] nil)
  (define-key menu-bar-help-menu [about-gnu-project] nil)
  
  
  
  ;; Process menu keyboard bindings
  
  (defun ergoemacs-shortcut-for-command (cmd)
    (let ((key (key-description (where-is-internal cmd nil t nil t))))
                                          ;(message "KEY \"%s\"" key)
      (let ((case-fold-search nil))
        (replace-regexp-in-string
         " " "  "
         (replace-regexp-in-string
          "<" ""
          (replace-regexp-in-string
           ">" ""
           (replace-regexp-in-string
            "\\bRET\\b" "ENTER"
            (replace-regexp-in-string
             "\\bprior\\b" "PgUp"
             (replace-regexp-in-string
              "\\bnext\\b" "PgDn"
              (replace-regexp-in-string
               "<f\\([0-9]+\\)>" "F\\1"
               (replace-regexp-in-string
                "\\b-\\b" "+"
                (replace-regexp-in-string
                 "\\b[[:lower:]]\\b" 'upcase
                 (replace-regexp-in-string
                  "\\b\\([[:upper:]]\\)\\b" "Shift+\\1"
                  (replace-regexp-in-string
                   "\\bC-" "Ctrl+"
                   (replace-regexp-in-string
                    "\\bS-" "Shift+"
                    (replace-regexp-in-string
                     "\\bM-" "Alt+" key t) t) t) t) t) t) t) t) t) t) t) t) t))))
  
  (defun ergoemacs-shortcut-for-menu-item (item)
    (if (and (>= (safe-length item) 4)
             (symbolp (car item))
             (eq (cadr item) 'menu-item)
             (stringp (caddr item))
             (symbolp (cadddr item))
             (not (keymapp (cadddr item))))
        ;; Look if this item already has a :keys property
        (if (position :keys item)
            nil
          (ergoemacs-shortcut-for-command (cadddr item)))
      nil))
  
  (defun ergoemacs-preprocess-menu-keybindings (menu)
    (unless (keymapp menu)
      (error "Invalid menu in ergoemacs-preprocess-menu-keybindings %s" menu))
    
    (when (symbolp menu)
      (setq menu (symbol-value menu)))
    
    ;; For each element in the menu
    (setcdr menu
            (mapcar (lambda (item)
                      (let ((key (ergoemacs-shortcut-for-menu-item item)))
                        (if key
                            (append item (cons :keys (cons key nil)))
                          item)))
                    (cdr menu)))
  
    ;; Recurse sub menu items
    (mapc (lambda (x)
            (when (and (consp x)
                       (consp (cdr x))
                       (consp (cdr (cdr x)))
                       (consp (cdr (cdr (cdr x))))
                       (eq (car (cdr x)) 'menu-item)
                       (keymapp (car (cdr (cdr (cdr x))))))
                                          ;(message "Submenu: %s" (car (cdr (cdr x))))
              (ergoemacs-preprocess-menu-keybindings (car (cdr (cdr (cdr x)))))))
          (cdr menu)))
  
  (ergoemacs-preprocess-menu-keybindings menu-bar-file-menu)
  (ergoemacs-preprocess-menu-keybindings menu-bar-edit-menu)
  (ergoemacs-preprocess-menu-keybindings menu-bar-bookmark-map)
  (ergoemacs-preprocess-menu-keybindings menu-bar-options-menu)
  (ergoemacs-preprocess-menu-keybindings menu-bar-tools-menu)
  (ergoemacs-preprocess-menu-keybindings (lookup-key menu-bar-tools-menu [shell]))
  (ergoemacs-preprocess-menu-keybindings menu-bar-help-menu)
  (ergoemacs-preprocess-menu-keybindings edit-popup-menu)
  
  (ergoemacs-preprocess-menu-keybindings
   (lookup-key lisp-interaction-mode-map [menu-bar lisp-interaction]))
  
  
  ;; TODO:
  
  ;; - call ergoemacs-preprocess-menu-keybindings for global-map (all menus of all modes)
  
  ;; - possibly add menu that shows the current minor modes in effect. (To implement, probably just call describe-mode. ) We might need this since we made C-h m to be describe-major-mode instead of describe-mode. But again maybe not since minor-modes is rather very technical specific to emacs, a concept and feature not in most editors.
  
  ;; - re-create menus from scratch, instead of piggy back to remove add. (done for the File menu) Because piggy back is difficult to do and manage and subject to emacs changes.
  
  ;; - reorg the help menu and submenu.
  
#+END_SRC

** Misc Settings
*** Window systems Settings
#+begin_src emacs-lisp 
  (when window-system
    (mouse-wheel-mode t)
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (prefer-coding-system 'utf-8)
    (put 'narrow-to-region 'disabled nil)
    (put 'upcase-region 'disabled nil)
    (put 'downcase-region 'disabled nil)
    (put 'erase-buffer 'disabled nil)
    (put 'scroll-left 'disabled nil)
    (put 'dired-find-alternate-file 'disabled nil)
    
  
    (with-no-warnings
      (setq visible-bell t
            echo-keystrokes 0.1
            font-lock-maximum-decoration t
            inhibit-startup-message t
            transient-mark-mode t
            color-theme-is-global t
            delete-by-moving-to-trash t
            shift-select-mode nil
            truncate-partial-width-windows nil
            uniquify-buffer-name-style 'forward
            whitespace-style '(trailing lines space-before-tab
                                        indentation space-after-tab)
            whitespace-line-column 100
            ediff-window-setup-function 'ediff-setup-windows-plain
            xterm-mouse-mode t
            save-place t)))
  (when (not (file-exists-p desktop-dirname))
    (make-directory desktop-dirname t))
  
#+end_src

*** Camel Case
Make camel case backward word work.
#+BEGIN_SRC emacs-lisp
(when (fboundp 'global-subword-mode ) (global-subword-mode 1))
#+END_SRC
*** Line Numbering
#+begin_src emacs-lisp
  (when (emacsmate-package-load-path 'linum-off)
    (require 'linum-off)
    (global-linum-mode 1))
    
#+end_src
*** Compression settings
#+BEGIN_SRC emacs-lisp
(auto-compression-mode t)
#+END_SRC


*** Spell Checking, Tabs, Imenu, and coding hook
#+BEGIN_SRC emacs-lisp
  (set-default 'indent-tabs-mode nil)
  (set-default 'indicate-empty-lines t)
  (set-default 'imenu-auto-rescan t)
  
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'text-mode-hook 'turn-on-flyspell)
  
  (defalias 'yes-or-no-p 'y-or-n-p)
  ;; Seed the random-number generator
  (random t)
#+END_SRC

*** Save History
Turn on save history to save history between sessions.
#+BEGIN_SRC emacs-lisp
  (savehist-mode 1)
#+END_SRC
*** Tabbar/Ruler & Project Management
Setup global tabbar and ruler.
#+BEGIN_SRC emacs-lisp
  (when (emacsmate-package-load-path 'tabbar-ruler)
    (with-no-warnings
      (setq tabbar-ruler-global-tabbar 't) ; If you want tabbar
      (setq tabbar-ruler-global-ruler 't) ; if you want a global ruler
      (setq tabbar-ruler-popup-menu 't) ; If you want a popup menu.
      (setq tabbar-ruler-popup-toolbar 't) ; If you want a popup toolbar
      )
    (require 'tabbar-ruler))
  
#+END_SRC
Also set it up to be used with projectile.

#+BEGIN_SRC emacs-lisp
  (setq projectile-require-project-root nil)
  (projectile-global-mode 1)
  
  
  (defvar tabbar-ruler-projectile-tabbar-buffer-group-calc nil
    "Buffer group for projectile.  Should be buffer local and speed up calculation of buffer groups.")
  (defun tabbar-ruler-projectile-tabbar-buffer-groups ()
    "Return the list of group names BUFFER belongs to.
      Return only one group for each buffer."
    (if tabbar-ruler-projectile-tabbar-buffer-group-calc
        (symbol-value 'tabbar-ruler-projectile-tabbar-buffer-group-calc)
      (set (make-local-variable 'tabbar-ruler-projectile-tabbar-buffer-group-calc)
           
           (cond
            ((or (get-buffer-process (current-buffer)) (memq major-mode '(comint-mode compilation-mode))) '("Term"))
            ((string-equal "*" (substring (buffer-name) 0 1)) '("Misc"))
            ((condition-case err
                 (projectile-project-root)
               (error nil)) (list (projectile-project-name)))
            ((memq major-mode '(emacs-lisp-mode python-mode emacs-lisp-mode c-mode c++-mode makefile-mode lua-mode vala-mode)) '("Coding"))
            ((memq major-mode '(javascript-mode js-mode nxhtml-mode html-mode css-mode)) '("HTML"))
            ((memq major-mode '(org-mode calendar-mode diary-mode)) '("Org"))
            ((memq major-mode '(dired-mode)) '("Dir"))
            (t '("Main"))))
      (symbol-value 'tabbar-ruler-projectile-tabbar-buffer-group-calc)))
  
  (with-no-warnings
    (setq tabbar-buffer-groups-function 'tabbar-ruler-projectile-tabbar-buffer-groups))
#+END_SRC
*** Cosmetics

#+begin_src emacs-lisp
(eval-after-load 'diff-mode
  '(progn
     (set-face-foreground 'diff-added "green4")
     (set-face-foreground 'diff-removed "red3")))

(eval-after-load 'magit
  '(progn
     (set-face-foreground 'magit-diff-add "green3")
     (set-face-foreground 'magit-diff-del "red3")))
#+end_src

** Saving File
#+BEGIN_SRC emacs-lisp
  (when (emacsmate-package-load-path 'info+)
    (require 'info+))
#+END_SRC
*** Backups
Rather than saving backup files scattered all over the file system,
let them live in the backups/directory inside of the temporary directory.
#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t)))
  
  ;; From http://emacswiki.org/emacs/BackupDirectory
  (message "Deleting old backup files...")
  (condition-case err
      (let ((week (* 60 60 24 7))
            (current (float-time (current-time))))
        (dolist (file (directory-files (expand-file-name "backups"
                                                         emacsmate-dir) t))
          (when (and (backup-file-name-p file)
                     (> (- current (float-time (fifth (file-attributes file))))
                        week))
            (message "%s" file)
            (delete-file file))))
    (error (message "Error deleting old backup files")))
  
#+END_SRC

*** Encoding
*** Save Automatically when
**** Focus is lost?
I don't believe this can be implemented in emacs (though it can in
Xemacs).  See:
http://stackoverflow.com/questions/1230245/how-to-automatically-save-files-on-lose-focus-in-emacs

However, saving can be toggled when actions occur in emacs.
** Color Theme
The EmacsMate package uses the Zenburn theme by default.
#+BEGIN_SRC emacs-lisp
  ;; (condition-case err
  ;;     (when (emacsmate-package-load-path 'zenburn-theme)
  ;;       (load-theme 'zenburn t))
  ;;   (error (message "Error Loading zenburn theme.")))
  
  (condition-case err
      (when (emacsmate-package-load-path 'solarized-theme)
        (load-theme 'solarized-light 't))
    (error (message "Error Loading Solarized theme")))
  
  ;; (condition-case err
  ;;     (when (emacsmate-package-load-path 'monokai-theme)
  ;;       (load-theme 'monokai-theme 't))
  ;;   (error (message "Error loading monokai-theme")))
#+END_SRC

** Key Frequency

Get Key Frequency data.  This is useful to try to help customize the
most ergonomic layouts. 

#+BEGIN_SRC emacs-lisp
  (when (emacsmate-package-load-path 'keyfreq)
    (with-no-warnings
      (setq keyfreq-file "~/.emacs.d/.emacs.keyfreq")
      (setq keyfreq-file-lock "~/.emacs.d/.emacs.keyfreq.lock")
      (setq keyfreq-autosave-timeout 600))
    (require 'keyfreq)
    (keyfreq-mode 1)
    (keyfreq-autosave-mode 1))
  
#+END_SRC

** Golden Ratio
This is to allow better views when working with multiple windows.  I
like it.  It looks nice.  See:
[[https://github.com/roman/golden-ratio.el][roman/golden-ratio.el · GitHub]]


I think it interferes with the calc interface, though.  I have added
these to the excluded buffers list.
#+BEGIN_SRC emacs-lisp
  (setq golden-ratio-exclude-buffer-names '("*Calculator*" "*Calc Trail*"))
  
  (condition-case err
      (golden-ratio-mode 1)
    (error (message "Golden Ratio did not load.")))
#+END_SRC

** Smartparens
#+BEGIN_SRC emacs-lisp
  (when (emacsmate-package-load-path 'smartparens)
    (require 'smartparens-config)
    (smartparens-global-mode)
    (show-smartparens-global-mode t)
    (add-hook 'emacs-lisp-mode-hook
              (lambda()
                (local-set-key (kbd ")") 'sp-up-sexp))))
#+END_SRC

